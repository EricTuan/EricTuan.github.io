{"pages":[{"title":"关于我","text":"欢迎来到我的个人博客! 博客内容记录一些平时遇到的问题、有趣的解决方案, 以及各种碎碎念等等 我的研究深度学习方向, 正在做人脸识别项目 联系方式 EMail: hrduan@qq.com","link":"/about/index.html"}],"posts":[{"title":"Deep-Compression-论文阅读","text":"结构 以上是Deep compression中所述的神经网络压缩方法，主要包括三个步骤： 剪枝：将部分很小的（认为不重要的）权值设为0，使权值矩阵转为一个稀疏矩阵 量化：将剪枝后保留的权值进行量化，使剪枝后保留的权值共享一些的使用一些值，这样可以减小保存权值使用的空间，进一步压缩所需要的存储空间 霍夫曼编码（可选）：霍夫曼编码是一种编码形式，可以减小数据的保存需要的存储空间剪枝剪枝生成的稀疏矩阵：首先是剪枝，首先通过正常训练相应的网络，然后设置一个阈值，把绝对值小于阈值的连接置为0，然后重新对网络进行训练，重复上面两个步骤来减少相应的权重连接。然后我们得到的是一个稀疏的权值矩阵。 由此权值矩阵可以使用存储稀疏矩阵的压缩存储方式存储，例如CSR(Compressed Sparse Row format)和CSC(Compressed Spare Column format)。该论文在CSR和CSC的基础上，将index上的值由绝对坐标转为偏移量。通过CSC得到了压缩的矩阵，可以通过差分存储进一步压缩存储数量。例如我们想用三比特的值来存储相应的Index。 3bit可以容忍的间距为8 当间距小于8时：用3比特的值就可以恢复出相应的位置 当间距大于8时：在第8个位置插入0值，然后用3bit的与插入的0值的差分位置恢复出相应的位置 间距大于8的倍数时：每隔8个位置插入0值，与最后一个0值的3bit的差分位置恢复出位置 Learning the connectivity via normal network training. 通过正常方法训练网络 We prune the small-weight connections: all connections with weights below a threshold are removed from the network. 将小于某个阈值的权重扔掉，设为0不再训练 We retrain the network to learn the final weights for the remaining sparse connections. 重新训练相应的网络剩下的权重 量化… Deep-compression阅读笔记Deep-Compression-AlexNet 源代码Deep Compression阅读理解及Caffe源码修改 Deep Compression’s video from ICLR’16 best paper award presentation","link":"/2019/01/22/Deep-Compression-论文阅读/"},{"title":"Django入门实践","text":"基础教程:Django2.0入门教程使用Pycharm里的Database对数据库进行可视化操作Pycharm新手教程,只需要看这篇就够了pycharm 为已存在的项目配置环境 Django博客教程 0. vscode 配置汉化和重要插件安装、使用 Visual Studio Code（VSCode）搭建简单的 Python + Django 开发环境 1. 建立项目1.1. 建立并激活虚拟环境123456789# 创建目录mkdir learning_logcd learning_log＃创建环境python -m venv ll_env＃激活环境source ll_env/bin/activate# 关闭环境deactivate 1.2. 安装Django1pip install Django 1.3. 创建项目1django-admin.py startproject learning_log . # 最后有一个句点，表示使用合适的目录结构 ＃# 1.4. 创建数据库1py manage.py migrate 1.5. 查看项目1py manage.py runserver 访问网站：http://127.0.0.1:8000/ 2. 创建应用程序1py manage.py startapp learning_logs 2.1. 定义模型修改models.py 2.2. 激活模型修改settings.py为1234567891011INSTALLED_APPS = [ &apos;django.contrib.admin&apos;, &apos;django.contrib.auth&apos;, &apos;django.contrib.contenttypes&apos;, &apos;django.contrib.sessions&apos;, &apos;django.contrib.messages&apos;, &apos;django.contrib.staticfiles&apos;, # 我的应用程序 &apos;learning_logs&apos;,] 让Django修改数据库，使其能够存储与模型Topic相关的信息1py manage.py makemigrations learning_logs 再应用这种迁移1py manage.py migrate 每当要修改管理的数据时，都要采取如下三个步骤：修改models.py; 对learning_logs调用makemigrations; 让Django迁移项目 2.3. 管理网站2.3.1. 创建超级用户1py manage.py createsuperuser 2.3.2. 向管理网站注册模型修改admin.py123from learning_logs.models import Topicadmin.site.register(Topic) 使用超级用户账户访问管理网站：http://127.0.0.1:8000/admin/ 2.3.3. 添加主题点击Topic之后进入主题网页，此时可以通过点击add进行主题的添加，添加完成之后点击save进行保存 2.4. 定义模型Entry修改learning_logs\\admin.py123456from django.contrib import adminfrom learning_logs.models import Topic, Entryadmin.site.register(Topic)admin.site.register(Entry) 返回管理网站可以发现多了一个板块接着点击新板块的add添加以下主题和讨论，并点击保存给我们之后测试使用。 2.4.1. django shell在输入以上数据之后，可以通过交互式终端会话访问这些数据，在测试项目和排除故障的时候会用上。执行命令python manage.py shell可以打开shell会话。得到查询集(queryset)： 知道对象的id，就可获取该对象并查看其任何属性：通过外键关系获取数据, 使用相关模型的小写名称、下划线、单词set： ＃３. 创建网页：学习笔记主页从入门到实践学习笔记-基于Django框架的Web开发-Django入门（三）12345678#learning_log/urls.pyfrom django.conf.urls import url，includefrom django.contrib import adminurlpatterns = [url(r&apos;^admin/&apos;, admin.site.urls),url(r&apos;&apos;, include(&apos;learning_logs.urls&apos;, namespace=&apos;learning_logs&apos;)),] 从入门到实践学习笔记-基于Django框架的Web开发-Django入门（四） learning_log/urls.py:12345678910111213141516171819202122232425&quot;&quot;&quot; 定义learning_logs的URL模式 &quot;&quot;&quot;from django.conf.urls import urlfrom . import views&quot;&quot;&quot;python3 Django 环境下，如果你遇到namespace没有注册以及在根目录下urls.py中的include方法的第二个参数namespace添加之后就出错的问题。请在[app_name]目录下的urls.py中的urlpatterns前面加上app_name=&apos;[app_name]&apos;， [app_name]代表你的应用的名称。可以参考这篇：https://stackoverflow.com/questions/14892462/django-error-upolls-is-not-a-registered-namespace&quot;&quot;&quot;app_name = &apos;learning_logs&apos; urlpatterns = [ # 主页 url(r&apos;^$&apos;, views.index, name = &apos;index&apos;), # 显示所有主题 url(r&apos;^topics/$&apos;, views.topics, name = &apos;topics&apos;), # 特定主题的详细页面 url(r&apos;^topics/(?P&lt;topic_id&gt;\\d+)/$&apos;, views.topic, name = &apos;topic&apos;),]","link":"/2019/01/23/Django入门实践/"},{"title":"Numpy中stack()函数详解","text":"stack()1. 函数原型stack(arrays, axis=0, out=None),功能： 沿新轴连接数组序列。 axis参数在结果的维度中指定新轴的索引。例如，如果轴=0，它将是第一个维度，如果轴=-1，它将是最后一个维度。2. 参数： arrays [输入为array_like的序列]每个array必须具有相同shape（这很重要，下文将提到） axis [int类型，可选参数]结果数组中的轴，输入数组沿其堆叠 out [ndarray类型，可选参数]放置结果的目的地3. 如何理解axis下面将从slice的角度出发，分析函数是如何作用的。先看看这个例子：– 单个列表作为输入1234567891011121314151617181920212223import nump这 as npa = [[1,2,3], [4,5,6]]print(&quot;原始列表如下：&quot;)print(a)print(&quot;增加维度：axis = 0&quot;)b = np.stack(a, axis = 0)print(b)print(&quot;增加维度：axis = 1&quot;)c = np.stack(a, axis = 1)print(c)输出：原始列表如下：[[1, 2, 3], [4, 5, 6]]增加维度：axis = 0[[1 2 3] [4 5 6]]增加维度：axis = 1[[1 4] [2 5] [3 6]] slice意为切片，怎么切呢？对上面这个例子中，输入只有a这个列表，但参数要求每个array必须具有相同shape，就一个输入为什么还要求相同维度？这不是莫名其妙吗，不用着急，看接下来的关于“切片”的操作分析。首先在python中，关于axis = 0 , 1: 使用0值表示沿着每一列或行标签\\索引值向下执行方法 使用1值表示沿着每一行或者列标签模向执行对应的方法 A. 当np.stack(a, axis = 0)时，我们沿axis=0轴（按行）切分得到:1234a = [[1,2,3], [4,5,6]]===&gt;[1,2,3] 和 [4,5,6]两个块（不准确的说法） 将这两个块沿axis = 1（按列）堆叠得到：123增加维度：axis = 0[[1 2 3] [4 5 6]] B. 当np.stack(a, axis = 1)时，我们沿axis=1轴（按列）切分得到:1234a = [[1,2,3], [4,5,6]]===&gt;[1,4] ，[2,5] 和 [3,6]三个块（不准确的说法） 将这两个块沿axis = 0（按行）堆叠得到：1234增加维度：axis = 1[[1 4] [2 5] [3 6]] 正是因为输入要进行切分和堆叠，才要求输入维度相同，这个维度相同是要求切片的维度相同！二维的很简单，按行切分则按列堆叠，列切分则行堆叠，但切分出来的块结构仍不清晰，等到三维的时候还要具体的例子。 接下来你可以分别看看下面两个例子。123456789101112131415161718192021222324252627import numpy as npa=[[1,2,3,4], [5,6,7,8], [9,10,11,12]]print(&quot;列表a如下：&quot;)print(a)print(&quot;增加一维，新维度的下标为0&quot;)c=np.stack(a,axis=0)print(c)print(&quot;增加一维，新维度的下标为1&quot;)c=np.stack(a,axis=1)print(c)输出：列表a如下：[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]增加一维，新维度的下标为0[[ 1 2 3 4] [ 5 6 7 8] [ 9 10 11 12]]增加一维，新维度的下标为1[[ 1 5 9] [ 2 6 10] [ 3 7 11] [ 4 8 12]] — 输入多个一维列表1234567891011121314151617181920212223242526272829import numpy as npa=[1,2,3,4]b=[5,6,7,8]c=[9,10,11,12]print(&quot;a=&quot;,a)print(&quot;b=&quot;,b)print(&quot;c=&quot;,c)print(&quot;增加一维，新维度的下标为0&quot;)d=np.stack((a,b,c),axis=0)print(d)print(&quot;增加一维，新维度的下标为1&quot;)d=np.stack((a,b,c),axis=1)print(d)输出：(&apos;a=&apos;, [1, 2, 3, 4])(&apos;b=&apos;, [5, 6, 7, 8])(&apos;c=&apos;, [9, 10, 11, 12])增加一维，新维度的下标为0[[ 1 2 3 4] [ 5 6 7 8] [ 9 10 11 12]]增加一维，新维度的下标为1[[ 1 5 9] [ 2 6 10] [ 3 7 11] [ 4 8 12]] 这个例子中，我们先把输入合成为(a,b,c)，即是如下的形式：123[[ 1 2 3 4] [ 5 6 7 8] [ 9 10 11 12]] 第二例子中其中a,b,c的维度相同，所以满足参数要求，即切片维度相同，你的输出和结果是一样吗？接下来，我们讨论一下axis=2的情况。照例我们先给出下面这个例子（啧啧，栗子好吃不嫌多啊QAQ）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import numpy as npa=[[1,2,3], [4,5,6]]b=[[1,2,3], [4,5,6]]c=[[1,2,3], [4,5,6]]print(&quot;a=&quot;,a)print(&quot;b=&quot;,b)print(&quot;c=&quot;,c)print(&quot;增加一维，新维度的下标为0&quot;)d=np.stack((a,b,c),axis=0)print(d)print(&quot;增加一维，新维度的下标为1&quot;)d=np.stack((a,b,c),axis=1)print(d)print(&quot;增加一维，新维度的下标为2&quot;)d=np.stack((a,b,c),axis=2)print(d)输出：(&apos;a=&apos;, [[1, 2, 3], [4, 5, 6]])(&apos;b=&apos;, [[1, 2, 3], [4, 5, 6]])(&apos;c=&apos;, [[1, 2, 3], [4, 5, 6]])增加一维，新维度的下标为0[[[1 2 3] [4 5 6]] [[1 2 3] [4 5 6]] [[1 2 3] [4 5 6]]]增加一维，新维度的下标为1[[[1 2 3] [1 2 3] [1 2 3]] [[4 5 6] [4 5 6] [4 5 6]]]增加一维，新维度的下标为2[[[1 1 1] [2 2 2] [3 3 3]] [[4 4 4] [5 5 5] [6 6 6]]] 我们最后详细分析一下：(a,b,c)的形式如下：123456[[[1 2 3] [4 5 6]] [[1 2 3] [4 5 6]] [[1 2 3] [4 5 6]]] A. 当np.stack((a,b,c),axis=1)时，我们沿axis=0轴（按行）切分得到:1234567注意一蛤，可不要切成[1,2,3] 和 [4,5,6]这样，因为是一个二维的整体（不要强行帮它剖腹。。。）块0 [[1,2,3], [4,5,6]] 块1 [[1,2,3], [4,5,6]] 块2 [[1,2,3], [4,5,6]] 将这3个块沿axis = 1（按列）堆叠得到：123456789增加一维，新维度的下标为0[[[1 2 3] [4 5 6]] [[1 2 3] [4 5 6]] [[1 2 3] [4 5 6]]] B. 当np.stack((a,b,c),axis=1)时，在情况A的基础上，我们将每个块沿按行切分（对多维数组切分，且分到二维时，就需要对行操作，下一次切分，再同时对列操作（就跟脱衣服一样，脱到上面一件和下面一件的时候，就可以同时操作了，咳咳），这样我们得到:123456789块0 [[1,2,3], [4,5,6]] ===&gt; [1,2,3] 和 [4,5,6]两个块块1 [[1,2,3], [4,5,6]] ===&gt; [1,2,3] 和 [4,5,6]两个块块2 [[1,2,3], [4,5,6]] ===&gt; [1,2,3] 和 [4,5,6]两个块 将块沿axis = 1（按列）堆叠得到：12345678910111213141516块0，块1，块2的子块，是同级的，故由上到下排列为：[[块0-子块0 块1-子块0 块2-子块0][块0-子块1 块1-子块1 块2-子块1]]即：[[[1 2 3] [1 2 3] [1 2 3]] [[4 5 6] [4 5 6] [4 5 6]]] B. 当np.stack((a,b,c),axis=2)时，在情况B的基础上，按列切分（其实，相当于行切分-行切分-列切分）123456789101112131415块0 [[1,2,3], [4,5,6]] ===&gt; [1,2,3] 和 [4,5,6]两个子块 ===&gt; 1，2，3 4，5，6块1 [[1,2,3], [4,5,6]] ===&gt; [1,2,3] 和 [4,5,6]两个块 ===&gt; 1，2，3 4，5，6块2 [[1,2,3], [4,5,6]] ===&gt; [1,2,3] 和 [4,5,6]两个块 ===&gt; 1，2，3 4，5，6 将块沿axis = 1（按列）堆叠得到：12345678910111213141516块0，块1，块2的子块，是同级的，故由上到下排列为：[[[块0-子块0-块0 块1-子块0-块0 块2-子块0-块0] [001 101 201] [002 102 202]] [[010 110 210] [011 111 211] [012 112 212]]]即：[[[1 1 1] [2 2 2] [3 3 3]] [[4 4 4] [5 5 5] [6 6 6]]] 三维是怎么做的呢？简单总结如下： axis = 0，直接按行切分，按列的方向堆叠axis = 1，对初始的矩阵，连续做两次行切分（先得到二维子块，再得到一维子块），最后按列的方向堆叠axis = 2，在上一步的基础上，做列切分（这样得到是具体的元素），再列堆叠 这里需要注意的是，同一级的子块同级堆叠","link":"/2019/01/10/Numpy中stack()函数详解/"},{"title":"Ubuntu-18-04-安装-PyCharm","text":"https://blog.csdn.net/qq_15192373/article/details/81091278 Python开发工具PyCharm个性化设置(图解) ubuntu下安装Mysql","link":"/2019/01/01/Ubuntu-18-04-安装-PyCharm/"},{"title":"Ubuntu18-0-4仿Mac界面","text":"关于几个目录，GTK、Shell的目录是：/usr/share/themes，图标的目录是/usr/share/icons。放到/usr/share/下是全局修改，也就是说如果你换一个账户登陆，也是可以用这些主题文件的。弊端就是操作较复杂，需要sudo权限。如果仅仅是想修改当前账户的主题，可以选择在/home/YourAccount/（比如 /home/feipeng8848/）下新建两个目录：.themes 和 .icons。注意，目录名称前面有个点 “ . ” ，然后把shell、GTK主题文件放到 .themes中，图标文件放到 .icons 中。 SHELLshell有个感叹号的话,可以注销账户登录,重启tweaks Ubuntu18.0.4仿Mac界面Ubuntu16.04 改造成 Mac OX给Ubuntu18.04安装mac os主题 BOOT在Search results for “plymouth”下载开机文件,解压后按照readme修改,再sudo运行install.sh,中间需要选择开机模式1 DOCKdask-to-dock 安装配置(图文教程)在 Ubuntu 里如何下载、安装和配置 Plank Dock LOGINGDM（GNOME Display Manager，GDM）主题，也就是登录界面的主题 选了一个主题https://www.opendesktop.org/s/Gnome/p/1207015/按步骤操作,备份原css,覆盖css,拷贝Setwallpaper脚本,最后直接对图片右键运行set as wallpaper","link":"/2019/01/01/Ubuntu18-0-4仿Mac界面/"},{"title":"conda管理","text":"1. 创建环境conda create -n envname 指定python版本conda create -n tfcpu python=3.5 2. 删除环境conda remove -n envname –all 3. 环境列表conda env list 4. 切换环境source activate envnamesource deactivate envname 5. 从文件中安装pip install -r requirements.txt 6. 查找包conda list pkgname","link":"/2019/01/21/conda管理/"},{"title":"dict和json格式转换","text":"同时解决： TypeError: Object of type ‘bytes’ is not JSON serializable默认的编码函数很多数据类型都不能编码，因此可以自己写一个encoder去继承jsonencoder ，这样就能够进行编码了 12345678910class MyEncoder(json.JSONEncoder): def default(self, obj): if isinstance(obj, np.integer): return int(obj) elif isinstance(obj, np.floating): return float(obj) elif isinstance(obj, np.ndarray): return obj.tolist() else: return super(MyEncoder, self).default(obj) dict to json123456def dict_to_json(dict_obj,name, Mycls = None): js_obj = json.dumps(dict_obj, cls = Mycls, indent=4) with open(name, &apos;w&apos;) as file_obj: file_obj.write(js_obj) json to dict1234def json_to_dict(filepath, Mycls = None): with open(filepath,&apos;r&apos;) as js_obj: dict_obj = json.load(js_obj, cls = Mycls) return dict_obj","link":"/2019/01/22/dict和json格式转换/"},{"title":"github搭建个人博客","text":"搭建Jekyll环境Ubuntu下搭建Jekyll环境 blog模板fork qiubaiying.github.ioGit 中 SSH key 生成步骤 clone前添加配置123git config --global user.name &apos;name&apos;git config --global user.email &apos;email@gmail.com&apos;ssh-keygen -t ras -C &apos;email@gmail.com&apos; 添加到githubSSH 评论系统正确的Disqus使用姿势Disqus 域名利用git搭建自己的个人博客github pages外部域名问题 #Django搭建博客效果展示","link":"/2019/01/22/github搭建个人博客/"},{"title":"import-其他目录下的模块","text":"程序结构如下：123456&gt;-- src |-- mod1.py |-- lib | |-- mod2.py |-- sub | |-- test2.py 这里想要实现test2.py调用mod1.py和mod2.py ，做法是我们先跳到src目录下面，直接可以调用mod1，然后在lib上当下建一个空文件init.py ，就可以像第二步调用子目录下的模块一样，通过import lib.mod2进行调用了。具体代码如下：1234import syssys.path.append(&quot;..&quot;)import mod1import mod2.mod2","link":"/2019/01/12/import-其他目录下的模块/"},{"title":"linux下文件解压","text":"1. tar命令主参数(模式)，以下参数有且只能有一个：-c: –create 新建一个压缩文档，即打包-x: –extract,–get解压文件-t: –list,查看压缩文档里的所有内容-r:–append 向压缩文档里追加文件-u:–update 更新原压缩包中的文件 可选项：-z ：用 gzip 压缩/解压缩-j ：用 bzip2 压缩/解压缩-v ：显示压缩/解压缩的进度条-f ：使用档名（f后面不要接参数，要立即接文档名） ##Examples:123tar -cf archive.tar foo bar # Create archive.tar from files foo and bar.tar -tvf archive.tar # List all files in archive.tar verbosely.tar -xf archive.tar # Extract all files from archive.tar. 2. unrar和7z12sudo apt install unrarsudo apt install p7zip-full Examples:12unrar e archive.rar7z x archive.7z","link":"/2019/01/10/linux下文件解压/"},{"title":"python-可变参数","text":"1. *args 数组参数argsFunc 中匹配完定义好的参数，剩余的参数以元组的形式存储在 args（args 名称你可以自行定义）1234567def argsFunc(a, *args): print(a) print(args) &gt;&gt;&gt; argsFunc(1, 2, 3, 4)1(2, 3, 4) 2. **kwargs 字典参数形参名前加两个*表示，参数在函数内部将被存放在以形式名为标识符的 dictionary 中，这时调用函数的方法则需要采用 arg1=value1,arg2=value2 这样的形式123&gt;&gt;&gt; def a(**x):print x&gt;&gt;&gt; a(x=1,y=2,z=3){&apos;y&apos;: 2, &apos;x&apos;: 1, &apos;z&apos;: 3} #存放在字典中 参考：简明Python 可变参数","link":"/2019/01/01/python-可变参数/"},{"title":"pygal的简单使用","text":"教程","link":"/2019/01/10/pygal的简单使用/"},{"title":"python-带默认值字典dict(可实现一对多)","text":"1. dict.setdefault()该接收两个参数，第一个参数是健的名称，第二个参数是默认值。假如字典中不存在给定的键，则返回参数中提供的默认值；反之，则返回字典中保存的值123456dict.setdefault(kw, 0) # 默认值设为0dict.setdefault(kw, []) # 默认值为空列表dict.setdefault(kw, []).append(value) # 把value增加到kw对应的键值列表中，实现了一对多dict.setdefault(kw, {}) # 默认值为空字典 # 可实现字典嵌套 2. defaultdict类collections.defaultdict提供了默认值的功能1234from collections import defaultdictdd = defaultdict(list) # 默认值为空列表形式dd[&apos;key&apos;].append(value1) # {&quot;key&quot;: [value1]}dd[&apos;key&apos;].append(value2) # {&quot;key&quot;: [value1, value2]} , 一个键值可以对应多个value 参考：理解 Python 语言中的 defaultdict","link":"/2019/01/02/python-带默认值字典dict(可实现一对多)/"},{"title":"python中open的模式","text":"r 只能读（read） r+ 可读可写，不会创建不存在的文件，如果直接写文件，则从顶部开始写，覆盖之前此位置的内容，如果先读后写，则会在文件最后追加内容（read+） w 只能写，覆盖整个文件，不存在则创建 （write） w+可读可写，如果文件存在则覆盖整个文件，不存在则创建 (write+) a 只能写，从文件底部添加内容，不存在则创建 a+ 可读可写，从文件顶部读取内容，从文件底部添加内容，不存在则创建","link":"/2019/01/10/python中open的模式/"},{"title":"python常见错误合集","text":"1. 引号不匹配123456789101112131415161718正确的格式:str1 = &apos;example 1 &apos;str2 = &quot;example 2 &quot;str3 = &quot;example &apos;3&apos; &quot;错误的格式:In [2]: str4 = &apos;It&apos;s example 4 &apos; # 单引号的string内还有有撇号`&apos;` File &quot;&lt;ipython-input-2-1bc6948cc597&gt;&quot;, line 1 str4 = &apos;It&apos;s example 4 &apos; ^SyntaxError: invalid syntaxIn [3]: str4 = &apos;example &apos;5&apos; &apos; File &quot;&lt;ipython-input-3-ae442a900f37&gt;&quot;, line 1 str4 = &apos;example &apos;5&apos; &apos; ^SyntaxError: invalid syntax 2. 索引错误常发生在列表数组等下标超过其本身的长度,可以用len()检查有时可能是空列表 3. 遗漏冒号for循环语句、函数定义、条件语句、try-except、等 4. 拷贝问题复制一个列表时123old = list(range(5))new = old[:] # 正确new_1 = old # 只是浅拷贝,这两个变量其实指向同一个列表 5. 对元组赋值元组类型不能修改其中元素,但可以对元组本身赋值等 6. 函数传入列表这种情况下，函数中对列表的操作会修改原列表，可以传入L[:] 7. import *可能遇到相同名称的函数或变量，导致覆盖 8. ValueError不能将带包含小数点的字符串’2.3’直接转换为整数,可以用int(float(‘2.3’)) more12import osos.system(&apos;clear&apos;)","link":"/2019/01/06/python常见错误合集/"},{"title":"python装饰器","text":"Python 装饰器记录总结 (终极版)","link":"/2019/01/01/python装饰器/"},{"title":"python-速成集中营(预览版)","text":"1. 计算部分1.1. / 、// 、 %除法(/)永远返回一个浮点数，如要使用 floor 除法 并且得到整数结果（丢掉任何小数部分），你可以使用 // 运算符；要计算余数你可以使用 %， 使用 ** 运算符计算幂乘方123456789&gt;&gt;&gt; 17 / 3 # classic division returns a float5.666666666666667&gt;&gt;&gt;&gt;&gt;&gt; 17 // 3 # floor division discards the fractional part5&gt;&gt;&gt; 17 % 3 # the % operator returns the remainder of the division2&gt;&gt;&gt; 5 * 3 + 2 # result * divisor + remainder17 1234&gt;&gt;&gt; 5 ** 2 # 5 squared25&gt;&gt;&gt; 2 ** 7 # 2 to the power of 7128 1.2. 交互模式中，最近一个表达式的值赋给变量 _12345678&gt;&gt;&gt; tax = 12.5 / 100&gt;&gt;&gt; price = 100.50&gt;&gt;&gt; price * tax12.5625&gt;&gt;&gt; price + _ #这玩意有点秀113.0625&gt;&gt;&gt; round(_, 2)113.06 1.3. decimal——定点数和浮点数的数学运算简单mark一下啊，是精确计算用的Decimal类型是在浮点类型的基础上设计的,但是它在几个地方上要优于floating point:1)Decimal类型可以非常精确地在计算机中存储,而学过c++的都知道,浮点型在计算机中是无法精确存储的,比如1.1和2.2在计算机中存储后,运算(1.1+2.2)表达式的值结果会是3.3000000000000003;Decimal类型则不会出现这种情况。同样,由于无法精确存储,浮点型也就无法精确计算(相对于Decimal类型),可以再测试(0.1+0.1+0.1-0.3)两种类型的计算结果。2)Decimal类型会自动保留小数点后面不需要的0,以与输入的精度相匹配,比如下面小程序中的例子:浮点型的1.20+1.30结果是2.5;而Decimal类型结果是2.50,这样貌似比较人性化。3)Decimal类型可以根据需要自己设置小数点后精度。通过getcontext().prec = x (x为你想要的精度来设置,getcontext()函数下面再详细介绍)。4)Decimal类型有很强的管理功能,它能够根据需要设置,来控制输出的格式,得到或者忽略某类错误(如除0,可以设置忽略它,而得到一个Infinity的Decimal值)。 1.4. 行尾’\\‘,表示：下一行在逻辑上是本行的后续内容字符串文本能够分成多行。一种方法是使用三引号：&quot;&quot;&quot;...&quot;&quot;&quot;或者'''...'''。行尾换行符会被自动包含到字符串中，但是可以在行尾加上\\来避免这个行为。下面的示例： 可以使用反斜杠为行结尾的连续字符串，它表示下一行在逻辑上是本行的后续内容:123456789print(&quot;&quot;&quot;\\Usage: thingy [OPTIONS] -h Display this usage message -H hostname Hostname to connect to&quot;&quot;&quot;)# 将生成以下输出（注意，没有开始的第一行）:Usage: thingy [OPTIONS] -h Display this usage message -H hostname Hostname to connect to 2. 字符串，列表2.1. s[:i] + s[i:] 永远等于s:注意，包含起始的字符，不包含末尾的字符。 2.2. Python字符串不可以被更改 — 它们是 不可变的 。因此，赋值给字符串索引的位置会导致错误:123456&gt;&gt;&gt; word[0] = &apos;J&apos; ...TypeError: &apos;str&apos; object does not support item assignment&gt;&gt;&gt; word[2:] = &apos;py&apos; ...TypeError: &apos;str&apos; object does not support item assignment 2.3. 可以对切片赋值，此操作可以改变列表的尺寸，或清空它:切片操作返回列表一个新的（浅）拷贝副本list[3] = value,也可以看作是一个切片，所以会改变原列表123456789101112131415&gt;&gt;&gt; letters = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;]&gt;&gt;&gt; letters[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;]&gt;&gt;&gt; # replace some values&gt;&gt;&gt; letters[2:5] = [&apos;C&apos;, &apos;D&apos;, &apos;E&apos;]&gt;&gt;&gt; letters[&apos;a&apos;, &apos;b&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;f&apos;, &apos;g&apos;]&gt;&gt;&gt; # now remove them&gt;&gt;&gt; letters[2:5] = []&gt;&gt;&gt; letters[&apos;a&apos;, &apos;b&apos;, &apos;f&apos;, &apos;g&apos;]&gt;&gt;&gt; # clear the list by replacing all the elements with an empty list&gt;&gt;&gt; letters[:] = []&gt;&gt;&gt; letters[] 2.4. 创建list啧啧，有点秀12list = [None] * nn为已知长度 for 语句就是这样一个迭代器。list() 函数是另外一个（ 迭代器 ），它从可迭代（对象）中创建列表:12&gt;&gt;&gt; list(range(5))[0, 1, 2, 3, 4] 3. 控制语句3.1. 修改你迭代的序列（例如，复制选择项），你可以迭代它的复本, 如for w in word[:]:在迭代过程中修改迭代序列不安全（只有在使用链表这样的可变序列时才会有这样的情况）。使用切割标识就可以很方便的做到这一点:123456&gt;&gt;&gt; for w in words[:]: # Loop over a slice copy of the entire list.... if len(w) &gt; 6:... words.insert(0, w)...&gt;&gt;&gt; words[&apos;defenestrate&apos;, &apos;cat&apos;, &apos;window&apos;, &apos;defenestrate&apos;] 3.2. 循环可以有一个 else 子句与循环一起使用时，else 子句与 try 语句的 else 子句比与 if 语句的具有更多的共同点：try 语句的 else 子句在未出现异常时运行，循环的 else 子句在未出现 break 时运行。更多关于 try 语句和异常的内容，请参见 异常处理。 循环可以有一个 else 子句；它在循环迭代完整个列表（对于 for ）或执行条件为 false （对于 while）时执行，但循环被 break 中止的情况下不会执行。以下搜索素数的示例程序演示了这个子句:1234567891011121314151617&gt;&gt;&gt; for n in range(2, 10):... for x in range(2, n):... if n % x == 0:... print(n, &apos;equals&apos;, x, &apos;*&apos;, n//x)... break... else:... # loop fell through without finding a factor... print(n, &apos;is a prime number&apos;)...2 is a prime number3 is a prime number4 equals 2 * 25 is a prime number6 equals 2 * 37 is a prime number8 equals 2 * 49 equals 3 * 3 4. 函数4.1. 用一个逗号结尾就可以禁止输出换行:或者 print(something, end='')123456&gt;&gt;&gt; a, b = 0, 1&gt;&gt;&gt; while b &lt; 1000:... print(b, end=&apos;,&apos;)... a, b = b, a+b...1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987, 4.2. 函数的参数4.2.1. 默认参数要求用户确认的函数例子：1234567891011def ask_ok(prompt, retries=4, complaint=&apos;Yes or no, please!&apos;): while True: ok = input(prompt) if ok in (&apos;y&apos;, &apos;ye&apos;, &apos;yes&apos;): return True if ok in (&apos;n&apos;, &apos;no&apos;, &apos;nop&apos;, &apos;nope&apos;): return False retries = retries - 1 if retries &lt; 0: raise OSError(&apos;uncooperative user&apos;) print(complaint) 默认值在函数 定义 作用域被解析1234567i = 5def f(arg=i): # f函数在这一行定义，默认参数被解析 print(arg)i = 6f() 将会输出 5重要警告: 默认值只被赋值一次。当默认值是可变对象时会有所不同，比如列表、字典或者大多数类的实例。例如，下面的函数在后续调用过程中会累积（前面）传给它的参数:123456789101112def f(a, L=[]): L.append(a) return Lprint(f(1))print(f(2))print(f(3))# 输出[1][1, 2][1, 2, 3] 如果你不想让默认值在后续调用中累积，你可以像下面一样定义函数:12345def f(a, L=None): if L is None: L = [] L.append(a) return L 4.2.2. 可变参数列表本质：元组封装和序列拆封的一个结合让函数调用可变个数的参数。这些参数被包装进一个元组（参见 元组和序列 ）。在这些可变个数的参数之前，可以有零到多个普通的参数。这些可变参数是参数列表中的最后一个，因为它们将把所有的剩余输入参数传递给函数。任何出现在 *args 后的参数是关键字参数，这意味着，他们只能被用作关键字，而不是位置参数:1234567&gt;&gt;&gt; def concat(*args, sep=&quot;/&quot;):... return sep.join(args)...&gt;&gt;&gt; concat(&quot;earth&quot;, &quot;mars&quot;, &quot;venus&quot;)&apos;earth/mars/venus&apos;&gt;&gt;&gt; concat(&quot;earth&quot;, &quot;mars&quot;, &quot;venus&quot;, sep=&quot;.&quot;) # sep只能是关键字参数！&apos;earth.mars.venus&apos; 4.2.3. 关键字参数引入一个形如 **name 的参数时，它接收一个字典（参见 Mapping Types — dict ），该字典包含了所有未出现在形式参数列表中的关键字参数。这里可能还会组合使用一个形如 *name （下一小节详细介绍） 的形式参数，它接收一个元组（下一节中会详细介绍），包含了所有没有出现在形式参数列表中的参数值（*name 必须在 `name` 之前出现**）。123456789def cheeseshop(kind, *arguments, **keywords): print(&quot;-- Do you have any&quot;, kind, &quot;?&quot;) print(&quot;-- I&apos;m sorry, we&apos;re all out of&quot;, kind) for arg in arguments: print(arg) print(&quot;-&quot; * 40) keys = sorted(keywords.keys()) # 对关键字排序 for kw in keys: print(kw, &quot;:&quot;, keywords[kw]) 4.2.4. 参数列表的分拆—— * 拆开参数列表, ** 分拆字典为关键字参数当你要传递的参数已经是一个列表，但要调用的函数却接受分开一个个的参数值。这时候你要把已有的列表拆开来。例如内建函数 range() 需要要独立的 start，stop 参数。你可以在调用函数时加一个 * 操作符来自动把参数列表拆开:12345&gt;&gt;&gt; list(range(3, 6)) # normal call with separate arguments[3, 4, 5]&gt;&gt;&gt; args = [3, 6]&gt;&gt;&gt; list(range(*args)) # call with arguments unpacked from a list[3, 4, 5] 以同样的方式，可以使用 ** 操作符分拆关键字参数为字典:12345678&gt;&gt;&gt; def parrot(voltage, state=&apos;a stiff&apos;, action=&apos;voom&apos;):... print(&quot;-- This parrot wouldn&apos;t&quot;, action, end=&apos; &apos;)... print(&quot;if you put&quot;, voltage, &quot;volts through it.&quot;, end=&apos; &apos;)... print(&quot;E&apos;s&quot;, state, &quot;!&quot;)...&gt;&gt;&gt; d = {&quot;voltage&quot;: &quot;four million&quot;, &quot;state&quot;: &quot;bleedin&apos; demised&quot;, &quot;action&quot;: &quot;VOOM&quot;}&gt;&gt;&gt; parrot(**d)-- This parrot wouldn&apos;t VOOM if you put four million volts through it. E&apos;s bleedin&apos; demised ! 4.3. Lambda 形式使用 lambda 表达式返回一个函数，类似于嵌套函数定义，lambda 形式可以从外部作用域引用变量:12345678&gt;&gt;&gt; def make_incrementor(n):... return lambda x: x + n...&gt;&gt;&gt; f = make_incrementor(42)&gt;&gt;&gt; f(0)42&gt;&gt;&gt; f(1) 43 或将一个小函数作为参数传递:1234&gt;&gt;&gt; pairs = [(1, &apos;one&apos;), (2, &apos;two&apos;), (3, &apos;three&apos;), (4, &apos;four&apos;)]&gt;&gt;&gt; pairs.sort(key=lambda pair: pair[1]) &gt;&gt;&gt; pairs[(4, &apos;four&apos;), (1, &apos;one&apos;), (3, &apos;three&apos;), (2, &apos;two&apos;)] 4.4. 函数的文档字符串第一行应该是关于对象用途的简介。简短起见，不用明确的陈述对象名或类型，因为它们可以从别的途径了解到（除非这个名字碰巧就是描述这个函数操作的动词）。这一行应该以大写字母开头，以句号结尾。 如果文档字符串有多行，第二行应该空出来，与接下来的详细描述明确分隔。接下来的文档应该有一或多段描述对象的调用约定、边界效应等。 Python 的解释器不会从多行的文档字符串中去除缩进，所以必要的时候应当自己清除缩进。这符合通常的习惯。第一行之后的第一个非空行决定了整个文档的缩进格式。（我们不用第一行是因为它通常紧靠着起始的引号，缩进格式显示的不清楚。）留白“相当于”是字符串的起始缩进。每一行都不应该有缩进，如果有缩进的话，所有的留白都应该清除掉。留白的长度应当等于扩展制表符的宽度（通常是8个空格）。 以下是一个多行文档字符串的示例:1234567891011&gt;&gt;&gt; def my_function():... &quot;&quot;&quot;Do nothing, but document it....... No, really, it doesn&apos;t do anything.... &quot;&quot;&quot;... pass...&gt;&gt;&gt; print(my_function.__doc__)Do nothing, but document it. No, really, it doesn&apos;t do anything. 4.5. 编码风格对于 Python，PEP 8 引入了大多数项目遵循的风格指导。它给出了一个高度可读，视觉友好的编码风格。每个 Python 开发者都应该读一下，大多数要点都会对你有帮助： 使用 4 空格缩进，而非 TAB 在小缩进（可以嵌套更深）和大缩进（更易读）之间，4空格是一个很好的折中。TAB 引发了一些混乱，最好弃用 折行以确保其不会超过 79 个字符这有助于小显示器用户阅读，也可以让大显示器能并排显示几个代码文件 使用空行分隔函数和类，以及函数中的大块代码 可能的话，注释独占一行 使用文档字符串 把空格放到操作符两边，以及逗号后面，但是括号里侧不加空格：a = f(1, 2) + g(3, 4) 统一函数和类命名推荐类名用 驼峰命名， 函数和方法名用 小写_和_下划线。总是用 self 作为方法的第一个参数（关于类和方法的知识详见 初识类 ） 不要使用花哨的编码，如果你的代码的目的是要在国际化环境。Python 的默认情况下，UTF-8，甚至普通的 ASCII 总是工作的最好 同样，也不要使用非 ASCII 字符的标识符，除非是不同语种的会阅读或者维护代码。5. 数据结构5.1. 列表level up list.append(x)：把一个元素添加到列表的结尾 list.extend(L)：将一个给定列表中的所有元素都添加到另一个列表中 list.insert(i, x)：在指定位置插入一个元素 list.remove(x)： 删除列表中值为 x 的第一个元素。如果没有这样的元素，就会返回一个错误。 list.pop([i])： 如果没有指定索引，a.pop() 返回最后一个元素 list.clear()： 从列表中删除所有元素 list.index(x)：返回列表中第一个值为 x 的元素的索引。如果没有匹配的元素就会返回一个错误。 list.count(x)：返回 x 在列表中出现的次数。 list.sort()：对列表中的元素就地进行排序。 list.reverse()：就地倒排 list.copy()：返回列表的一个浅拷贝。等同于 a[:]。5.1.1. 把列表当作堆栈使用堆栈作为特定的数据结构，最先进入的元素最后一个被释放（后进先出）。用 append() 方法可以把一个元素添加到堆栈顶。用不指定索引的 pop()方法可以把一个元素从堆栈顶释放出来。例如:5.1.2. 把列表当作队列使用队列作为特定的数据结构，最先进入的元素最先释放（先进先出）。不过，列表这样用效率不高。要实现队列，使用 collections.deque，它为在首尾两端快速插入和删除而设计。例如:12345678910&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; queue = deque([&quot;Eric&quot;, &quot;John&quot;, &quot;Michael&quot;])&gt;&gt;&gt; queue.append(&quot;Terry&quot;) # Terry arrives&gt;&gt;&gt; queue.append(&quot;Graham&quot;) # Graham arrives&gt;&gt;&gt; queue.popleft() # The first to arrive now leaves&apos;Eric&apos;&gt;&gt;&gt; queue.popleft() # The second to arrive now leaves&apos;John&apos;&gt;&gt;&gt; queue # Remaining queue in order of arrivaldeque([&apos;Michael&apos;, &apos;Terry&apos;, &apos;Graham&apos;]) 5.2. del 语句从列表中按给定的索引而不是值来删除一个子项1234567891011&gt;&gt;&gt; a = [-1, 1, 66.25, 333, 333, 1234.5]&gt;&gt;&gt; del a[0]&gt;&gt;&gt; a[1, 66.25, 333, 333, 1234.5]&gt;&gt;&gt; del a[2:4]&gt;&gt;&gt; a[1, 66.25, 1234.5]&gt;&gt;&gt; del a[:]&gt;&gt;&gt; a[]&gt;&gt;&gt; del a # 也可以删除整个变量 5.3. 元组123456789&gt;&gt;&gt; t = 12345, 54321, &apos;hello!&apos;&gt;&gt;&gt; t[0]12345&gt;&gt;&gt; t(12345, 54321, &apos;hello!&apos;)&gt;&gt;&gt; # Tuples may be nested:... u = t, (1, 2, 3, 4, 5) # 封装成元组&gt;&gt;&gt; u((12345, 54321, &apos;hello!&apos;), (1, 2, 3, 4, 5)) 一对空的括号可以创建空元组创建一个单元素元组可以在值后面跟一个逗号（在括号中放入一个单值不够明确）1234&gt;&gt;&gt; empty = ()&gt;&gt;&gt; singleton = &apos;hello&apos;, # &lt;-- note trailing comma&gt;&gt;&gt; singleton(&apos;hello&apos;,) 元组拆分：x, y, z = t 5.4. 集合集合是一个无序不重复元素的集。基本功能包括关系测试和消除重复元素。集合对象还支持 union（联合），intersection（交），difference（差）和 sysmmetric difference（对称差集）等数学运算。注意：想要创建空集合，你必须使用 set() 而不是 {}。后者用于创建空字典。12345678910111213141516171819202122&gt;&gt;&gt; basket = {&apos;apple&apos;, &apos;orange&apos;, &apos;apple&apos;, &apos;pear&apos;, &apos;orange&apos;, &apos;banana&apos;}&gt;&gt;&gt; print(basket) # show that duplicates have been removed{&apos;orange&apos;, &apos;banana&apos;, &apos;pear&apos;, &apos;apple&apos;}&gt;&gt;&gt; &apos;orange&apos; in basket # fast membership testingTrue&gt;&gt;&gt; &apos;crabgrass&apos; in basketFalse&gt;&gt;&gt; # Demonstrate set operations on unique letters from two words...&gt;&gt;&gt; a = set(&apos;abracadabra&apos;)&gt;&gt;&gt; b = set(&apos;alacazam&apos;)&gt;&gt;&gt; a # unique letters in a{&apos;a&apos;, &apos;r&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;}&gt;&gt;&gt; a - b # letters in a but not in b{&apos;r&apos;, &apos;d&apos;, &apos;b&apos;}&gt;&gt;&gt; a | b # letters in either a or b{&apos;a&apos;, &apos;c&apos;, &apos;r&apos;, &apos;d&apos;, &apos;b&apos;, &apos;m&apos;, &apos;z&apos;, &apos;l&apos;}&gt;&gt;&gt; a &amp; b # letters in both a and b{&apos;a&apos;, &apos;c&apos;}&gt;&gt;&gt; a ^ b # letters in a or b but not both{&apos;r&apos;, &apos;d&apos;, &apos;b&apos;, &apos;m&apos;, &apos;z&apos;, &apos;l&apos;} 类似 列表推导式，这里有一种集合推导式语法:123&gt;&gt;&gt; a = {x for x in &apos;abracadabra&apos; if x not in &apos;abc&apos;}&gt;&gt;&gt; a{&apos;r&apos;, &apos;d&apos;} 5.5. 字典无序的键： 值对 （key:value 对）集合，键必须是互不相同的（在同一个字典之内）。一对大括号创建一个空的字典： {} 。初始化列表时，在大括号内放置一组逗号分隔的键：值对，这也是字典输出的方式。对一个字典执行 list(d.keys()) 将返回一个字典中所有关键字组成的无序列表（如果你想要排序，只需使用 sorted(d.keys()) ）。使用 in 关键字可以检查字典中是否存在某个关键字（指字典）。 直接从 key-value 对中创建字典: 12&gt;&gt;&gt; dict([(&apos;sape&apos;, 4139), (&apos;guido&apos;, 4127), (&apos;jack&apos;, 4098)]){&apos;sape&apos;: 4139, &apos;jack&apos;: 4098, &apos;guido&apos;: 4127} 字典推导式可以从任意的键值表达式中创建字典: 12&gt;&gt;&gt; {x: x**2 for x in (2, 4, 6)}{2: 4, 4: 16, 6: 36} 通过关键字参数指定 key-value 对: 12&gt;&gt;&gt; dict(sape=4139, guido=4127, jack=4098){&apos;sape&apos;: 4139, &apos;jack&apos;: 4098, &apos;guido&apos;: 4127} 5.6. 循环技巧 在字典中循环时，关键字和对应的值可以使用items() 方法同时解读出来: 123&gt;&gt;&gt; knights = {&apos;gallahad&apos;: &apos;the pure&apos;, &apos;robin&apos;: &apos;the brave&apos;}&gt;&gt;&gt; for k, v in knights.items():... print(k, v) 同时循环两个或更多的序列，可以使用 zip() 整体打包: 1234&gt;&gt;&gt; questions = [&apos;name&apos;, &apos;quest&apos;, &apos;favorite color&apos;]&gt;&gt;&gt; answers = [&apos;lancelot&apos;, &apos;the holy grail&apos;, &apos;blue&apos;]&gt;&gt;&gt; for q, a in zip(questions, answers):... print(&apos;What is your {0}? It is {1}.&apos;.format(q, a)) 逆向循环序列的话，先正向定位序列，然后调用 reversed() 函数: 12&gt;&gt;&gt; for i in reversed(range(1, 10, 2)):... print(i) 要按排序后的顺序循环序列的话，使用 sorted() 函数 123&gt;&gt;&gt; basket = [&apos;apple&apos;, &apos;orange&apos;, &apos;apple&apos;, &apos;pear&apos;, &apos;orange&apos;, &apos;banana&apos;]&gt;&gt;&gt; for f in sorted(set(basket)):... print(f) 要在循环内部修改正在遍历的序列（例如复制某些元素），建议您首先制作副本,使用切片表示法 1234&gt;&gt;&gt; words = [&apos;cat&apos;, &apos;window&apos;, &apos;defenestrate&apos;]&gt;&gt;&gt; for w in words[:]: # Loop over a slice copy of the entire list.... if len(w) &gt; 6:... words.insert(0, w) 5.7. 深入条件控制 比较操作符 in 和 not in 审核值是否在一个区间之内。操作符 is 和is not 比较两个对象是否相同 比较操作可以传递。例如a &lt; b == c 审核是否 a 小于b 并且b 等于c 比较操作可以通过逻辑操作符 and 和 or组合，比较的结果可以用 not来取反义。这些操作符的优先级又低于比较操作符，在它们之中，not 具有最高的优先级，or优先级最低，所以 A and not B or C 等于 (A and (notB)) or C5.8 比较序列和其它类型1234567(1, 2, 3) &lt; (1, 2, 4)[1, 2, 3] &lt; [1, 2, 4]&apos;ABC&apos; &lt; &apos;C&apos; &lt; &apos;Pascal&apos; &lt; &apos;Python&apos; # 字符串的字典序按照单字符的 ASCII 顺序(1, 2, 3, 4) &lt; (1, 2, 4)(1, 2) &lt; (1, 2, -1) # 如果一个序列是另一个序列的初始子序列，较短的一个序列就小于另一个(1, 2, 3) == (1.0, 2.0, 3.0) # 混合数值类型是通过它们的数值进行比较的，所以 0 是等于 0.0(1, 2, (&apos;aa&apos;, &apos;ab&apos;)) &lt; (1, 2, (&apos;abc&apos;, &apos;a&apos;), 4) 6. 模块6.1. 模块载入出于性能考虑，每个模块在每个解释器会话中只导入一遍。因此，如果你修改了你的模块，需要重启解释器；或者，如果你就是想交互式的测试这么一个模块，可以用 imp.reload() 重新加载，例如 import imp; imp.reload(modulename)。 6.2. 模块的搜索路径导入一个叫 spam 的模块时，解释器先在当前目录中搜索名为 spam.py 的文件。如果没有找到的话，接着会到 sys.path 变量中给出的目录列表中查找。 sys.path 变量的初始值来自如下： 输入脚本的目录（当前目录）。 环境变量 PYTHONPATH 表示的目录列表中搜索(这和 shell 变量 PATH 具有一样的语法，即一系列目录名的列表)。 Python 默认安装路径中搜索。 在支持符号连接的文件系统中，输入的脚本所在的目录是符号连接指向的目录。 换句话说也就是包含符号链接的目录不会被加到目录搜索路径中。 变量 sys.path 是解释器模块搜索路径的字符串列表。它由环境变量 PYTHONPATH 初始化，如果没有设定 PYTHONPATH ，就由内置的默认值初始化。你可以用标准的字符串操作修改它:12&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path.append(&apos;/ufs/guido/lib/python&apos;) 6.3. dir() 函数内置函数 dir() 用于按模块名搜索模块定义，它返回一个字符串类型的存储列表:123&gt;&gt;&gt; import fibo, sys&gt;&gt;&gt; dir(fibo)[&apos;__name__&apos;, &apos;fib&apos;, &apos;fib2&apos;] 无参数调用时，dir() 函数返回当前定义的命名:12345&gt;&gt;&gt; a = [1, 2, 3, 4, 5]&gt;&gt;&gt; import fibo&gt;&gt;&gt; fib = fibo.fib&gt;&gt;&gt; dir()[&apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__name__&apos;, &apos;a&apos;, &apos;fib&apos;, &apos;fibo&apos;, &apos;sys&apos;] 该列表列出了所有类型的名称：变量，模块，函数，等等。dir() 不会列出内置函数和变量名。如果你想列出这些内容，它们在标准模块 builtins 中定义:12&gt;&gt;&gt; import builtins&gt;&gt;&gt; dir(builtins) 6.4. 包一个声音处理的模块集，目录结构如下：1234567891011121314151617181920212223sound/ Top-level package __init__.py Initialize the sound package formats/ Subpackage for file format conversions __init__.py wavread.py wavwrite.py aiffread.py aiffwrite.py auread.py auwrite.py ... effects/ Subpackage for sound effects __init__.py echo.py surround.py reverse.py ... filters/ Subpackage for filters __init__.py equalizer.py vocoder.py karaoke.py ... 当导入这个包时，Python 通过 sys.path 搜索路径查找包含这个包的子目录。为了让 Python 将目录当做内容包，目录中必须包含 __init__.py 文件。最简单的情况下，只需要一个空的 __init__.py 文件即可。当然它也可以执行包的初始化代码，或者定义稍后介绍的 __all__ 变量。 6.4.1. 导入包的几种方式：1234# 加载 echo 子模块echo.echofilter(input, output, delay=0.7, atten=4)# 直接导入函数或变量from sound.effects.echo import echofilter 6.4.2. 从 * 导入包提供一个明确的包索引。import 语句按如下条件进行转换：执行 from package import * 时，如果包中的 __init__.py 代码定义了一个名为 __all__ 的列表，就会按照列表中给出的模块名进行导入。新版本的包发布时作者可以任意更新这个列表。如果包作者不想 import 的时候导入他们的包中所有模块，那么也可能会决定不支持它（ import ）。例如， sound/effects/__init__.py 这个文件可能包括如下代码:1__all__ = [&quot;echo&quot;, &quot;surround&quot;, &quot;reverse&quot;] 这意味着from sound.effects import 语句会从 sound 包中导入以上三个已命名的子模块。 6.4.3. 包内引用可以用这样的形式from module import name 来写显式的相对位置导入。那些显式相对导入用点号标明关联导入当前和上级包。以 surround 模块为例，你可以这样用:123from . import echofrom .. import formatsfrom ..filters import equalizer 需要注意的是显式或隐式相对位置导入都基于当前模块的命名。因为主模块的名字总是&quot;__main__&quot;，Python 应用程序的主模块应该总是用绝对导入。 7. 输入和输出7.1. 格式化输出这里有两种大相径庭地输出值方法：表达式语句 和 print() 函数（第三种访求是使用文件对象的 write() 方法，标准文件输出可以参考 sys.stdout，详细内容参见库参考手册）。 str.format() 方法提供了丰富的格式控制。如何将值转化为字符串？Python 有办法将任意值转为字符串：将它传入 repr() 或 str() 函数。函数 str() 用于将值转化为适于人阅读的形式，而 repr() 转化为供解释器读取的形式（如果没有等价的语法，则会发生 SyntaxError 异常）某对象没有适于人阅读的解释形式的话，str() 会返回与 repr()等同的值。 7.2. str的一些方法 str.rjust() 方法，它把字符串输出到一列，并通过向左侧填充空格来使其右对齐。类似的方法还有 str.ljust() 和 str.center()。这些函数只是输出新的字符串，并不改变什么。如果输出的字符串太长，它们也不会截断它，而是原样输出。如果你确实需要截断它，可以使用切割操作，例如：x.ljust(n)[:n]。 str.zfill() 它用于向数值的字符串表达左侧填充 0。该函数可以正确理解正负号: 123456&gt;&gt;&gt; &apos;12&apos;.zfill(5)&apos;00012&apos;&gt;&gt;&gt; &apos;-3.14&apos;.zfill(7)&apos;-003.14&apos;&gt;&gt;&gt; &apos;3.14159265359&apos;.zfill(5)&apos;3.14159265359&apos; str.format() 的基本用法如下: 12&gt;&gt;&gt; print(&apos;We are the {} who say &quot;{}!&quot;&apos;.format(&apos;knights&apos;, &apos;Ni&apos;))We are the knights who say &quot;Ni!&quot; 大括号和其中的字符会被替换成传入 str.format() 的参数。大括号中的数值指明使用传入 str.format()方法的对象中的哪一个:1234&gt;&gt;&gt; print(&apos;{0} and {1}&apos;.format(&apos;spam&apos;, &apos;eggs&apos;))spam and eggs&gt;&gt;&gt; print(&apos;{1} and {0}&apos;.format(&apos;spam&apos;, &apos;eggs&apos;))eggs and spam 如果在 str.format() 调用时使用关键字参数，可以通过参数名来引用值:123&gt;&gt;&gt; print(&apos;This {food} is {adjective}.&apos;.format(... food=&apos;spam&apos;, adjective=&apos;absolutely horrible&apos;))This spam is absolutely horrible. 位置参数和关键字参数可以随意组合:123&gt;&gt;&gt; print(&apos;The story of {0}, {1}, and {other}.&apos;.format(&apos;Bill&apos;, &apos;Manfred&apos;, other=&apos;Georg&apos;))The story of Bill, Manfred, and Georg. '!a' (应用 ascii())，'!s' （应用 str() ）和 '!r' （应用 repr() ）可以在格式化之前转换值:12345&gt;&gt;&gt; import math&gt;&gt;&gt; print(&apos;The value of PI is approximately {}.&apos;.format(math.pi))The value of PI is approximately 3.14159265359.&gt;&gt;&gt; print(&apos;The value of PI is approximately {!r}.&apos;.format(math.pi))The value of PI is approximately 3.141592653589793. 字段名后允许可选的':' 和格式指令。下例将 Pi 转为三位精度。123&gt;&gt;&gt; import math&gt;&gt;&gt; print(&apos;The value of PI is approximately {0:.3f}.&apos;.format(math.pi))The value of PI is approximately 3.142. 在字段后的 ‘:’ 后面加一个整数会限定该字段的最小宽度，这在美化表格时很有用:1234567&gt;&gt;&gt; table = {&apos;Sjoerd&apos;: 4127, &apos;Jack&apos;: 4098, &apos;Dcab&apos;: 7678}&gt;&gt;&gt; for name, phone in table.items():... print(&apos;{0:10} ==&gt; {1:10d}&apos;.format(name, phone))...Jack ==&gt; 4098Dcab ==&gt; 7678Sjoerd ==&gt; 4127 可以用命名来引用被格式化的变量而不是位置。传入一个字典，用中括号( '[]')访问它的键:1234&gt;&gt;&gt; table = {&apos;Sjoerd&apos;: 4127, &apos;Jack&apos;: 4098, &apos;Dcab&apos;: 8637678}&gt;&gt;&gt; print(&apos;Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; &apos; &apos;Dcab: {0[Dcab]:d}&apos;.format(table))Jack: 4098; Sjoerd: 4127; Dcab: 8637678 也可以用 ‘**’ 标志将这个字典以关键字参数的方式传入:123&gt;&gt;&gt; table = {&apos;Sjoerd&apos;: 4127, &apos;Jack&apos;: 4098, &apos;Dcab&apos;: 8637678}&gt;&gt;&gt; print(&apos;Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: {Dcab:d}&apos;.format(**table))Jack: 4098; Sjoerd: 4127; Dcab: 8637678 这种方式与新的内置函数 vars() 组合使用非常有效。该函数返回包含所有局部变量的字典。 要进一步了解字符串格式化方法 str.format()，参见 格式字符串语法。 7.2. 文件读写函数 open() 返回 文件对象，通常的用法需要两个参数：open(filename, mode)。1&gt;&gt;&gt; f = open(&apos;workfile&apos;, &apos;w&apos;) 第一个参数是一个含有文件名的字符串。第二个参数也是一个字符串，含有描述如何使用该文件的几个字符。mode 为 ‘r’ 时表示只是读取文件；’w’ 表示只是写入文件（已经存在的同名文件将被删掉）；’a’ 表示打开文件进行追加，写入到文件中的任何数据将自动添加到末尾。 ‘r+’ 表示打开文件进行读取和写入。mode 参数是可选的，默认为 ‘r’。 通常，文件以 文本 打开，这意味着，你从文件读出和向文件写入的字符串会被特定的编码方式（默认是UTF-8）编码。模式后面的 ‘b’ 以 二进制模式 打开文件：数据会以字节对象的形式读出和写入。这种模式应该用于所有不包含文本的文件。 在文本模式下，读取时默认会将平台有关的行结束符（Unix上是 \\n , Windows上是 \\r\\n）转换为 \\n。在文本模式下写入时，默认会将出现的 \\n 转换成平台有关的行结束符。这种暗地里的修改对 ASCII 文本文件没有问题，但会损坏 JPEG 或 EXE 这样的二进制文件中的数据。使用二进制模式读写此类文件时要特别小心。 7.2.1. 文件对象方法要读取文件内容，需要调用f.read(size)，该方法读取若干数量的数据并以字符串形式返回其内容，size 是可选的数值，指定字符串长度。如果没有指定 size 或者指定为负数，就会读取并返回整个文件。当文件大小为当前机器内存两倍时，就会产生问题。反之，会尽可能按比较大的 * 读取和返回数据。如果到了文件末尾，f.read() 会返回一个空字符串（''）:1234&gt;&gt;&gt; f.read()&apos;This is the entire file.\\n&apos;&gt;&gt;&gt; f.read()&apos;&apos; f.readline()从文件中读取单独一行，字符串结尾会自动加上一个换行符（\\n ），只有当文件最后一行没有以换行符结尾时，这一操作才会被忽略。 如果f.readline() 返回一个空字符串，那就表示到达了文件末尾 如果是一个空行，就会描述为 '\\n'，一个只包含换行符的字符串:123456&gt;&gt;&gt; f.readline()&apos;This is the first line of the file.\\n&apos;&gt;&gt;&gt; f.readline()&apos;Second line of the file\\n&apos;&gt;&gt;&gt; f.readline()&apos;&apos; 把文件中的所有行读到一个列表中，可以使用 list(f) 或者f.readlines()。 f.write(string) 方法将 string 的内容写入文件，并返回写入字符的长度:12&gt;&gt;&gt; f.write(&apos;This is a test\\n&apos;)15 想要写入其他非字符串内容，首先要将它转换为字符串。 当你使用完一个文件时，调用 f.close() 方法就可以关闭它并释放其占用的所有系统资源。 在调用 f.close() 方法后，试图再次使用文件对象将会自动失败。用关键字 with 处理文件对象是个好习惯。它的先进之处在于文件用完后会自动关闭，就算发生异常也没关系。它是 try-finally 块的简写:1234&gt;&gt;&gt; with open(&apos;workfile&apos;, &apos;r&apos;) as f:... read_data = f.read()&gt;&gt;&gt; f.closedTrue 7.2.2. 使用 json 存储结构化数据Python 允许你使用常用的数据交换格式 JSON（JavaScript Object Notation）。标准模块 json 可以接受 Python 数据结构，并将它们转换为字符串表示形式；此过程称为 序列化。从字符串表示形式重新构建数据结构称为 反序列化。序列化和反序列化的过程中，表示该对象的字符串可以存储在文件或数据中，也可以通过网络连接传送给远程的机器。如果你有一个对象 x，你可以用简单的一行代码查看其 JSON 字符串表示形式:12&gt;&gt;&gt; json.dumps([1, &apos;simple&apos;, &apos;list&apos;])&apos;[1, &quot;simple&quot;, &quot;list&quot;]&apos; dumps() 函数的另外一个变体 dump()，直接将对象序列化到一个文件。所以如果 f 是为写入而打开的一个 文件对象，我们可以这样做:1json.dump(x, f) 为了重新解码对象，如果 f 是为读取而打开的 文件对象:1x = json.load(f) 这种简单的序列化技术可以处理列表和字典，但序列化任意类实例为 JSON 需要一点额外的努力。 json 模块的手册对此有详细的解释。 7.2.3. pickle - pickle 模块与 JSON 不同，pickle 是一个协议，它允许任意复杂的 Python 对象的序列化。因此，它只能用于 Python 而不能用来与其他语言编写的应用程序进行通信。默认情况下它也是不安全的：如果数据由熟练的攻击者精心设计， 反序列化来自一个不受信任源的 pickle 数据可以执行任意代码。 8. 错误和异常Python 中（至少）有两种错误：语法错误和异常（ syntax errors 和 exceptions ）。 8.1. 语法错误语法错误，也被称作解析错误。这是最常见的错误，往往是由于缺少冒号或者括号等引起。12345&gt;&gt;&gt; while True print(&apos;Hello world&apos;) File &quot;&lt;stdin&gt;&quot;, line 1, in ? while True print(&apos;Hello world&apos;) ^SyntaxError: invalid syntax 语法分析器指出错误行，并且在检测到错误的位置前面显示一个小“箭头”。 错误是由箭头 前面 的标记引起的（或者至少是这么检测的）： 这个例子中，函数 print() 被发现存在错误，因为它前面少了一个冒号（ ':' ）。 错误会输出文件名和行号。 8.2. 异常即使一条语句或表达式在语法上是正确的，当试图执行它时也可能会引发错误。运行期检测到的错误称为 异常，并且程序不会无条件的崩溃：123456789101112&gt;&gt;&gt; 10 * (1/0)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?ZeroDivisionError: int division or modulo by zero&gt;&gt;&gt; 4 + spam*3Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?NameError: name &apos;spam&apos; is not defined&gt;&gt;&gt; &apos;2&apos; + 2Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?TypeError: Can&apos;t convert &apos;int&apos; object to str implicitly 错误信息的最后一行指出发生了什么错误。异常也有不同的类型，异常类型做为错误信息的一部分显示出来：示例中的异常分别为 零除错误（ ZeroDivisionError ） ，命名错误（ NameError） 和 类型错误（ TypeError ）。打印错误信息时，异常的类型作为异常的内置名显示。对于所有的内置异常都是如此，不过用户自定义异常就不一定了（尽管这是一个很有用的约定）。标准异常名是内置的标识（没有保留关键字）。 这一行后一部分是关于该异常类型的详细说明，这意味着它的内容依赖于异常类型。 错误信息的前半部分以堆栈的形式列出异常发生的位置。通常在堆栈中列出了源代码行，然而，来自标准输入的源码不会显示出来。 内置的异常 列出了内置异常和它们的含义。 8.3. 异常处理通过编程处理选择的异常是可行的。看一下下面的例子：它会一直要求用户输入，直到输入一个合法的整数为止，但允许用户中断这个程序（使用 Control-C 或系统支持的任何方法）。注意：用户产生的中断会引发一个 KeyboardInterrupt 异常。1234567&gt;&gt;&gt; while True:... try:... x = int(input(&quot;Please enter a number: &quot;))... break... except ValueError:... print(&quot;Oops! That was no valid number. Try again...&quot;)... 8.3.1 try - except - else 语句try 语句按如下方式工作。 首先，执行 try 子句 （在 try 和 except 关键字之间的部分）。 如果没有异常发生， except 子句 在 try 语句执行完毕后就被忽略了。 如果在 try 子句执行过程中发生了异常，那么该子句其余的部分就会被忽略。如果异常匹配于 except 关键字后面指定的异常类型，就执行对应的except子句。然后继续执行 try 语句之后的代码。 如果发生了一个异常，在 except 子句中没有与之匹配的分支，它就会传递到上一级 try 语句中。如果最终仍找不到对应的处理语句，它就成为一个 未处理异常，终止程序运行，显示提示信息。 一个 try 语句可能包含多个 except 子句，分别指定处理不同的异常。至多只会有一个分支被执行。异常处理程序只会处理对应的 try 子句中发生的异常，在同一个 try 语句中，其他子句中发生的异常则不作处理。一个 except 子句可以在括号中列出多个异常的名字，例如:12... except (RuntimeError, TypeError, NameError):... pass 最后一个 except 子句可以省略异常名称，以作为通配符使用。你需要慎用此法，因为它会轻易隐藏一个实际的程序错误！可以使用这种方法打印一条错误信息，然后重新抛出异常（允许调用者处理这个异常):12345678910111213import systry: f = open(&apos;myfile.txt&apos;) s = f.readline() i = int(s.strip())except OSError as err: print(&quot;OS error: {0}&quot;.format(err))except ValueError: print(&quot;Could not convert data to an integer.&quot;)except: print(&quot;Unexpected error:&quot;, sys.exc_info()[0]) raise try … except 语句可以带有一个 else子句，该子句只能出现在所有 except 子句之后。当 try 语句没有抛出异常时，需要执行一些代码，可以使用这个子句。例如:12345678for arg in sys.argv[1:]: try: f = open(arg, &apos;r&apos;) except IOError: print(&apos;cannot open&apos;, arg) else: print(arg, &apos;has&apos;, len(f.readlines()), &apos;lines&apos;) f.close() 使用 else 子句比在 try 子句中附加代码要好，因为这样可以避免 try … except 意外的截获本来不属于它们保护的那些代码抛出的异常。 8.3.2 异常的参数发生异常时，可能会有一个附属值，作为异常的 参数 存在。这个参数是否存在、是什么类型，依赖于异常的类型。 在异常名（列表）之后，也可以为 except 子句指定一个变量。这个变量绑定于一个异常实例，它存储在 instance.args 的参数中。为了方便起见，异常实例定义了 str () ，这样就可以直接访问过打印参数而不必引用 .args。这种做法不受鼓励。相反，更好的做法是给异常传递一个参数（如果要传递多个参数，可以传递一个元组），把它绑定到 message 属性。一旦异常发生，它会在抛出前绑定所有指定的属性。12345678910111213141516&gt;&gt;&gt; try:... raise Exception(&apos;spam&apos;, &apos;eggs&apos;)... except Exception as inst:... print(type(inst)) # the exception instance... print(inst.args) # arguments stored in .args... print(inst) # __str__ allows args to be printed directly,... # but may be overridden in exception subclasses... x, y = inst.args # unpack args... print(&apos;x =&apos;, x)... print(&apos;y =&apos;, y)...&lt;class &apos;Exception&apos;&gt;(&apos;spam&apos;, &apos;eggs&apos;)(&apos;spam&apos;, &apos;eggs&apos;)x = spamy = eggs 对于那些未处理的异常，如果一个它们带有参数，那么就会被作为异常信息的最后部分（“详情”）打印出来。 异常处理器不仅仅处理那些在 try 子句中立刻发生的异常，也会处理那些 try 子句中调用的函数内部发生的异常。 8.4. 抛出异常raise 语句允许程序员强制抛出一个指定的异常。例如:1234&gt;&gt;&gt; raise NameError(&apos;HiThere&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?NameError: HiThere 要抛出的异常由 raise 的唯一参数标识。它必需是一个异常实例或异常类（继承自 Exception 的类）。 如果你需要明确一个异常是否抛出，但不想处理它，raise 语句可以让你很简单的重新抛出该异常:12345678910&gt;&gt;&gt; try:... raise NameError(&apos;HiThere&apos;)... except NameError:... print(&apos;An exception flew by!&apos;)... raise...An exception flew by!Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 2, in ?NameError: HiThere 8.5. 用户自定义异常在程序中可以通过创建新的异常类型来命名自己的异常。异常类通常应该直接或间接的从 Exception 类派生，例如:12345678910111213141516&gt;&gt;&gt; class MyError(Exception):... def __init__(self, value):... self.value = value... def __str__(self):... return repr(self.value)...&gt;&gt;&gt; try:... raise MyError(2*2)... except MyError as e:... print(&apos;My exception occurred, value:&apos;, e.value)...My exception occurred, value: 4&gt;&gt;&gt; raise MyError(&apos;oops!&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?__main__.MyError: &apos;oops!&apos; 在这个例子中，Exception 默认的 init() 被覆盖。新的方式简单的创建 value 属性。这就替换了原来创建 args 属性的方式。 异常类中可以定义任何其它类中可以定义的东西，但是通常为了保持简单，只在其中加入几个属性信息，以供异常处理句柄提取。如果一个新创建的模块中需要抛出几种不同的错误时，一个通常的作法是为该模块定义一个异常基类，然后针对不同的错误类型派生出对应的异常子类:123456789101112131415161718192021222324252627282930class Error(Exception): &quot;&quot;&quot;Base class for exceptions in this module.&quot;&quot;&quot; passclass InputError(Error): &quot;&quot;&quot;Exception raised for errors in the input. Attributes: expression -- input expression in which the error occurred message -- explanation of the error &quot;&quot;&quot; def __init__(self, expression, message): self.expression = expression self.message = messageclass TransitionError(Error): &quot;&quot;&quot;Raised when an operation attempts a state transition that&apos;s not allowed. Attributes: previous -- state at beginning of transition next -- attempted new state message -- explanation of why the specific transition is not allowed &quot;&quot;&quot; def __init__(self, previous, next, message): self.previous = previous self.next = next self.message = message 8.6. 定义清理行为try 语句还有另一个可选的子句，目的在于定义在任何情况下都一定要执行的功能。例如:12345678910111213141516171819202122&gt;&gt;&gt; def divide(x, y):... try:... result = x / y... except ZeroDivisionError:... print(&quot;division by zero!&quot;)... else:... print(&quot;result is&quot;, result)... finally:... print(&quot;executing finally clause&quot;)...&gt;&gt;&gt; divide(2, 1)result is 2executing finally clause&gt;&gt;&gt; divide(2, 0)division by zero!executing finally clause&gt;&gt;&gt; divide(&quot;2&quot;, &quot;1&quot;)executing finally clauseTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ? File &quot;&lt;stdin&gt;&quot;, line 3, in divideTypeError: unsupported operand type(s) for /: &apos;str&apos; and &apos;str&apos; 不管有没有发生异常，finally子句 在程序离开 try 后都一定会被执行。当 try 语句中发生了未被 except 捕获的异常（或者它发生在 except 或 else 子句中），在 finally 子句执行完后它会被重新抛出。 try 语句经由 break ，continue 或 return 语句退 出也一样会执行 finally 子句。 finally 子句在任何情况下都会执行。TypeError 在两个字符串相除的时候抛出，未被 except 子句捕获，因此在 finally 子句执行完毕后重新抛出。 在真实场景的应用程序中，finally 子句用于释放外部资源（文件 或网络连接之类的），无论它们的使用过程中是否出错。 9. 类 Python中的作用域及global用法python中global 和 nonlocal 的作用域9.7. 补充有时类似于 Pascal 中“记录（record）”或 C 中“结构（struct）”的数据类型很有用，它将一组已命名的数据项绑定在一起。一个空的类定义可以很好的实现它: 10.10. 性能度量有些用户对了解解决同一问题的不同方法之间的性能差异很感兴趣。Python 提供了一个度量工具，为这些问题提供了直接答案。 例如，使用元组封装和拆封来交换元素看起来要比使用传统的方法要诱人的多。timeit 证明了后者更快一些: 12345&gt;&gt;&gt; from timeit import Timer&gt;&gt;&gt; Timer(&apos;t=a; a=b; b=t&apos;, &apos;a=1; b=2&apos;).timeit()0.57535828626024577&gt;&gt;&gt; Timer(&apos;a,b = b,a&apos;, &apos;a=1; b=2&apos;).timeit()0.54962537085770791&lt;/pre&gt; 相对于 timeit 的细粒度，profile 和 pstats 模块提供了针对更大代码块的时间度量工具。 pip freeze 将会生成一个类似需要安装的包的列表，但是输出采用了 pip install 期望的格式。常见的做法就是把它们放在一个 requirements.txt 文件: requirements.txt 能够被提交到版本控制中并且作为一个应用程序的一部分。用户们可以使用 install -r 安装所有必须的包: what’s morehttp://www.pythondoc.com/pythontutorial3/classes.html","link":"/2019/01/01/python-速成集中营-—-预览版/"},{"title":"python遍历文件夹及其子目录","text":"1. os.listdir(path)返回指定的文件夹包含的文件或文件夹的名字的列表 2. walk(top, topdown=True, onerror=None, followlinks=False)参数 top 是你所要遍历的目录的地址 topdown 为真，则优先遍历top目录，否则优先遍历top的子目录(默认为开启) onerror 需要一个 callable 对象，当walk需要异常时，会调用 followlinks 如果为真，则会遍历目录下的快捷方式(linux 下是 symbolic link)实际所指的目录(默认关闭) os.walk 的返回值是一个生成器(generator),也就是说我们需要不断的遍历它，来获得所有的内容。每次遍历的对象都是返回的是一个三元组(root,dirs,files) root 所指的是当前正在遍历的这个文件夹的本身的地址 dirs 是一个 list ，内容是该文件夹中所有的目录的名字(不包括子目录) files 同样是 list , 内容是该文件夹中所有的文件(不包括子目录) 一个使用例子，利用生成器，每次用.next()取得一个返回值，送入函数处理，直到所有的值已取得：123456root_dirs_files = os.walk(folderpath)while True: try: your_function(root_dirs_files.__next__()) except StopIteration: break 一个小提示：在python 3.x中 generator（有yield关键字的函数则会被识别为generator函数）中的next变为__next__了,next是python 3.x以前版本中的方法 3. 另附os.path模块os.path.abspath(path) #返回绝对路径os.path.basename(path) #返回文件名os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。os.path.dirname(path) #返回文件路径os.path.exists(path) #路径存在则返回True,路径损坏返回Falseos.path.lexists #路径存在则返回True,路径损坏也返回Trueos.path.expanduser(path) #把path中包含的”~”和”~user”转换成用户目录os.path.expandvars(path) #根据环境变量的值替换path中包含的”$name”和”${name}”os.path.getatime(path) #返回最后一次进入此path的时间。os.path.getmtime(path) #返回在此path下最后一次修改的时间。os.path.getctime(path) #返回path的大小os.path.getsize(path) #返回文件大小，如果文件不存在就返回错误os.path.isabs(path) #判断是否为绝对路径os.path.isfile(path) #判断路径是否为文件os.path.isdir(path) #判断路径是否为目录os.path.islink(path) #判断路径是否为链接os.path.ismount(path) #判断路径是否为挂载点（）os.path.join(path1[, path2[, …]]) #把目录和文件名合成一个路径os.path.normcase(path) #转换path的大小写和斜杠os.path.normpath(path) #规范path字符串形式os.path.realpath(path) #返回path的真实路径os.path.relpath(path[, start]) #从start开始计算相对路径os.path.samefile(path1, path2) #判断目录或文件是否相同os.path.sameopenfile(fp1, fp2) #判断fp1和fp2是否指向同一文件os.path.samestat(stat1, stat2) #判断stat tuple stat1和stat2是否指向同一个文件os.path.split(path) #把路径分割成dirname和basename，返回一个元组os.path.splitdrive(path) #一般用在windows下，返回驱动器名和路径组成的元组os.path.splitext(path) #分割路径，返回路径名和文件扩展名的元组os.path.splitunc(path) #把路径分割为加载点与文件os.path.walk(path, visit, arg) #遍历path，进入每个目录都调用visit函数，visit函数必须有3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有文件名，args则为walk的第三个参数os.path.supports_unicode_filenames #设置是否支持unicode路径名 参考：python中os.walk的用法python os.path模块","link":"/2019/01/01/python遍历文件夹及其子目录/"},{"title":"ubuntu小花样","text":"1. 查看安装的所有软件dpkg -l 例如：dpkg -l | grep ftp 2. 安装截屏，设置快捷键 433 sudo apt-get install aria2 434 sudo add-apt-repository ppa:apt-fast/stable 435 sudo apt-get update 436 sudo apt-get -y install apt-fast 437 sudo apt-get update 438 sudo apt-fast install deepin-screenshot 439 deepin-screenshot 440 sudo apt install ntpdate 441 sudo ntpdate time.windows.com 442 sudo hwclock –localtime –systohc 443 deepin-terminal 444 expect -f /tmp/deepin-terminal-47UGVZ 445 expect -f /tmp/deepin-terminal-X5NKVZ 3. Ubuntu 18.04 网易云音乐无法打开最简单解决办法将当前用户加入 sudoer1sudo visudo -f /etc/sudoers.d/username username 要替换为你系统用户名并输入：1username ALL=(ALL:ALL) NOPASSWD:ALL 如果不习惯使用nano编辑器可以 更换为vim 使用 sudo 运行网易云音乐编辑启动文件：1sudo gedit /usr/share/applications/netease-cloud-music.desktop 在第11行前加上 sudo1Exec=sudo netease-cloud-music %U 大功告成！点击图标即可启动！ 系统版本：Ubuntu 18.04.1软件版本：netease-cloud-music 1.1.0 4. 如何在Ubuntu下彻底并安全的卸载软件？12345678apt-get remove --purge xxx # 移除应用及配置apt-get autoremove # 移除没用的包安装的时候当然一并就安装了。apt-get remove xxx 就是删除xxx，对于依赖则是不管的。因为别的软件也会和此软件有相同的依赖，当然对依赖不能管了。 apt-get autoremove 就是来对付那些不再“依赖”的包， 自动检测并删除他们。所以你可以先apt-get remove xxx然后，或者隔一段时间apt-get autoremove 5. Goldendict字典添加字典时应包含文件夹linux（所有版本）下安装有道词典goldendict安装与配置 6. 搜狗輸入法ubuntu 18.04 LTS如何安装搜狗输入法 7. 设置开机启动ubuntu-18.04 设置开机启动脚本ubuntu-18.04 设置开机启动脚本 8. Linux 命令总记不住咋办？tldr 帮你忙1234安装pip install tldr使用tldr xxx LDR 全称是 Too Long, Don’t Read，也就是太长不看的意思github - tldr ＃ 6. 壁纸在应用市场下载Wonderwall或者从网页下载图片wallpapers","link":"/2019/01/01/ubuntu小花样/"},{"title":"通过在vscode配置sftp, 远程修改服务器文件","text":"安装sftp扩展在vscode扩展中搜索sftp，下载量超过一百万的那个就是了，作者是liximomo。 按F1键搜索SFTP:Config,接下来配置sftp.json, 注意不要注释1234567891011121314151617181920212223242526{ &quot;host&quot;: &quot;server-ip&quot;, &quot;port&quot;: server-port, &quot;username&quot;: &quot;***&quot;, &quot;password&quot;: &quot;***&quot;, &quot;protocol&quot;: &quot;sftp&quot;, &quot;agent&quot;: null, &quot;privateKeyPath&quot;: null, &quot;passphrase&quot;: null, &quot;passive&quot;: false, &quot;interactiveAuth&quot;: true, &quot;remotePath&quot;: &quot;yourfolderpath&quot;, &quot;uploadOnSave&quot;: true, &quot;syncMode&quot;: &quot;update&quot;, &quot;ignore&quot;: [ &quot;**/.vscode/**&quot;, &quot;**/.git/**&quot;, &quot;**/.DS_Store&quot; ], &quot;watcher&quot;: { &quot;files&quot;: &quot;glob&quot;, &quot;autoUpload&quot;: true, &quot;autoDelete&quot;: true }} 在本地编辑远程文件并测试按F1键搜索view:Show SFTP，在vscode的右侧会出现SFTP的图标，在这里可以查看到远程文件打开一个远程文件初始内容是现在我们修改一下需要注意的是，修改完成后你保存的只是本地副本，还需要经过上传，才能达到真正修改的目的，右键选择upload即可，为了方便起见，这里修改一下快捷键，连续按下ctrl+k和ctrl+s，再ctrl+f搜索upload，将对应项快捷键设为ctrl+alt+s上传之后，源文件就已经和本地编辑器相同了","link":"/2019/01/20/vscode-+-sftp/"},{"title":"一些命令","text":"1. find dirpath/ -ctime -1列出dirpath下所有一天内的新文件 2. commend | tee mylog.log在终端执行一条命令时，同时使用tee命令，可以将屏幕输出保存到指定文件中，方便查看 3. ls -l|grep “^-“| wc -l列出当前文件夹下目录文件数 Python产生一个数值范围内的不重复的随机数，可以使用random模块中的random.sample函数 在python3中列出所有keys到列表, firstStr = list(myTree.keys()) assert 2==1,’2不等于1’ （1）直接赋值,默认浅拷贝传递对象的引用而已,原始列表改变，被赋值的b也会做相同的改变（2）copy浅拷贝，没有拷贝子对象，所以原始数据改变，子对象会改变 import copy c=copy.copy(alist)（3）深拷贝，包含对象里面的自对象的拷贝，所以原始对象的改变不会造成深拷贝里任何子元素的改变import copy d=copy.deepcopy(alist)","link":"/2019/01/01/一些命令/"},{"title":"卷积神经网络的参数量和计算量-+-Depthwise卷积与Pointwise卷积","text":"1. 感受野终于在知乎上中找到深度神经网络中的感受野(Receptive Field) - 蓝荣祎的文章 - 知乎http://zhuanlan.zhihu.com/p/28492837 算是弄清了基本原理，记录以备忘 1.先举个例子： e.g.两层 3*3 卷积操作的有效区域(感受野)是5*5 (所有filter的stride=1,pad=0),示意图如下： 三层3*3卷积核操作的有效区域是7*7 (所有filter的stride=1，pad=0),示意图如下： 2. 基本定义： 定义：感受野用来表示网络内部的不同神经元对原图像的感受范围的大小，或者说，convNets(cnn)每一层输出的特征图(feature map)上的像素点在原始图像上映射的区域大小。 神经元之所以无法对原始图像的所有信息进行感知，是因为在这些网络结构中普遍使用卷积层和pooling层，在层与层之间均为局部连接。 神经元感受野的值越大表示其能接触到的原始图像范围就越大，也意味着它可能蕴含更为全局，语义层次更高的特征；相反，值越小则表示其所包含的特征越趋向局部和细节。因此感受野的值可以用来大致判断每一层的抽象层次。 3. 感受野的计算 可以看到在Conv1中的每一个单元所能看到的原始图像范围是3*3，而由于Conv2的每个单元都是由 2*2范围的Conv1构成，因此回溯到原始图像，其实是能够看到5*5的原始图像范围的。因此我们说Conv1的感受野是3，Conv2的感受野是5. 输入图像的每个单元的感受野被定义为1，这应该很好理解，因为每个像素只能看到自己。 在上图中，数字代表某单元能够看到的原始图像像素，我们用r_n表示第n个卷积层中，每个单元的感受野，用k_n和s_n表示第n个卷积层的kernel_size和stride.对Raw Image进行kernel_size=3, stride 2的卷积操作所得到的fmap1 (fmap为feature map的简称，为每一个conv层所产生的输出)的结果是显而易见的。序列[1 2 3]表示fmap1的第一个单元能看见原图像中的1，2，3这三个像素，而第二个单元则能看见3，4，5。这两个单元随后又被kernel_size=2，stride 1的Filter 2进行卷积，因而得到的fmap2的第一个单元能够看见原图像中的1,2,3,4,5共5个像素（即取[1 2 3]和[3 4 5]的并集）。接下来我们尝试一下如何用公式来表述上述过程。可以看到，[1 2 3]和[3 4 5]之间因为Filter 1的stride 2而错开（偏移）了两位，而3是重叠的。对于卷积两个感受野为3的上层单元，下一层最大能获得的感受野为 3*2=6，但因为有重叠，因此要减去(kernel_size - 1)个重叠部分，而重叠部分的计算方式则为感受野减去前面所说的偏移量，这里是2. 因此我们就得到 继续往下一层看，我们会发现[1 2 3 4 5]和[3 4 5 6 7]的偏移量仍为2，并不简单地等于上一层的s_2, 这是因为之前的stride对后续层的影响是永久性的，而且是累积相乘的关系（例如，在fmap3中，偏移量已经累积到4了），也就是说 r_3应该这样求 同理： 。。。。。。可抽象如下： 理解：第n个卷积层的感受野等于前一个卷积层的感受野输出再乘以第n卷积层的kernel_size,即第n卷积层要合并多少个，这里算出的是总的量，还要减去之间有重复的量，第n卷积层总共要合并k_n个，那么前后两两相比较，空隙共有k_n-1个，比如说：第一层和第二层有重复，第二层和第三层也有重复等等，然后就要计算每两个之间重复的量有多少，首先每层共有r_n-1个数字，需要减去往右偏移的量，即stride，第1卷积层的stride_1,第二层会在第一层的基础上偏移stride_2,即总共偏移了 stride_1*stride_2,即偏移量是一个乘积的累计效果，所以式子如下： 经过去括号简化。可得下面式子： 参考：Receptive field(感受野) 2. 全局平均池化（GAP）所谓的全局就是针对常用的平均池化而言，平均池化会有它的filter size，比如 2 * 2，全局平均池化就没有size，它针对的是整张feature map. 全局平均池化（Global average Pooling）由 M. Lin, Q. Chen, and S. Yan. Network in network. Interna-tional Conference on Learning Representations, 2014.提出来。 用个简单的例子来说明它的过程，作用请看原文献或者百度。 一个feature map 全局平均池化后得到一个值，再进行全连接（softmax）就会少很多参数。参考：对全局平均池化（GAP）过程的理解 3. 卷积神经网络的复杂度分析单个卷积层的时间复杂度卷积神经网络整体的时间复杂度 空间复杂度（访存量），严格来讲包括两部分：总参数量 + 各层输出特征图。 参数量：模型所有带参数的层的权重参数总量（即模型体积，下式第一个求和表达式） 特征图：模型在实时运行过程中每层所计算出的输出特征图大小（下式第二个求和表达式） 时间复杂度和空间复杂度计算，Inception 系列模型是如何优化复杂度的以VGG为例，分析深度网络的计算量和参数量TensorFlow中CNN的两种padding方式“SAME”和“VALID” 让深度学习更高效运行的两个视角当这个应用程序的计算密度大于一定值之后，将会变成一个受算术逻辑单元的计算量所限制的程序；而这个计算密度如果小于一定值，将会变成一个受存储器带宽所限制的程序。计算量和访存量 Depthwise卷积与Pointwise卷积Depthwise Separable Convolution是将一个完整的卷积运算分解为两步进行，即Depthwise Convolution与Pointwise Convolution","link":"/2019/01/01/卷积神经网络的参数量和计算量-+-Depthwise卷积与Pointwise卷积/"},{"title":"深度学习面试经验合集","text":"深度学习岗位面试问题整理笔记总结一点面试问题－－算法工程师（机器学习）","link":"/2019/01/12/深度学习面试经验合集/"},{"title":"程序运行时间","text":"123456start = time.time()run(something)end = time.time()print(end-start)","link":"/2019/01/01/程序运行时间/"},{"title":"解决Tensorflow-使用时cpu编译不支持警告","text":"运行Tensorflow时出现以下警告，原因是下载TensorFlow的版本不支持cpu的AVX2编译 1234567`import os os.environ[&quot;TF_CPP_MIN_LOG_LEVEL&quot;]=&apos;1&apos; # 这是默认的显示等级，显示所有信息 os.environ[&quot;TF_CPP_MIN_LOG_LEVEL&quot;]=&apos;2&apos; # 只显示 warning 和 Error os.environ[&quot;TF_CPP_MIN_LOG_LEVEL&quot;]=&apos;3&apos; # 只显示 Error&apos;","link":"/2019/01/13/解决Tensorflow-使用时cpu编译不支持警告/"}],"tags":[{"name":"深度学习","slug":"深度学习","link":"/tags/深度学习/"},{"name":"模型优化","slug":"模型优化","link":"/tags/模型优化/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"Django","slug":"Django","link":"/tags/Django/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"conda","slug":"conda","link":"/tags/conda/"},{"name":"json","slug":"json","link":"/tags/json/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"个人博客","slug":"个人博客","link":"/tags/个人博客/"},{"name":"解压","slug":"解压","link":"/tags/解压/"},{"name":"bug","slug":"bug","link":"/tags/bug/"},{"name":"小花样","slug":"小花样","link":"/tags/小花样/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"sftp","slug":"sftp","link":"/tags/sftp/"},{"name":"远程连接","slug":"远程连接","link":"/tags/远程连接/"},{"name":"服务器","slug":"服务器","link":"/tags/服务器/"},{"name":"CNN","slug":"CNN","link":"/tags/CNN/"},{"name":"面试经验","slug":"面试经验","link":"/tags/面试经验/"},{"name":"tensorflow","slug":"tensorflow","link":"/tags/tensorflow/"}],"categories":[{"name":"深度学习","slug":"深度学习","link":"/categories/深度学习/"},{"name":"python","slug":"python","link":"/categories/python/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"模型优化","slug":"深度学习/模型优化","link":"/categories/深度学习/模型优化/"},{"name":"conda","slug":"python/conda","link":"/categories/python/conda/"},{"name":"Django","slug":"python/Django","link":"/categories/python/Django/"},{"name":"json","slug":"python/json","link":"/categories/python/json/"},{"name":"github","slug":"github","link":"/categories/github/"},{"name":"numpy","slug":"python/numpy","link":"/categories/python/numpy/"},{"name":"import模块","slug":"python/import模块","link":"/categories/python/import模块/"},{"name":"解压","slug":"linux/解压","link":"/categories/linux/解压/"},{"name":"软件安装","slug":"linux/软件安装","link":"/categories/linux/软件安装/"},{"name":"基础","slug":"python/基础","link":"/categories/python/基础/"},{"name":"pygal","slug":"python/pygal","link":"/categories/python/pygal/"},{"name":"网络剪枝","slug":"深度学习/模型优化/网络剪枝","link":"/categories/深度学习/模型优化/网络剪枝/"},{"name":"主题美化","slug":"linux/主题美化","link":"/categories/linux/主题美化/"},{"name":"bug","slug":"python/bug","link":"/categories/python/bug/"},{"name":"tricks","slug":"linux/tricks","link":"/categories/linux/tricks/"},{"name":"vscode","slug":"vscode","link":"/categories/vscode/"},{"name":"命令","slug":"linux/命令","link":"/categories/linux/命令/"},{"name":"参数量和计算量","slug":"深度学习/模型优化/参数量和计算量","link":"/categories/深度学习/模型优化/参数量和计算量/"},{"name":"面试经验","slug":"深度学习/面试经验","link":"/categories/深度学习/面试经验/"},{"name":"个人博客","slug":"github/个人博客","link":"/categories/github/个人博客/"},{"name":"tricks","slug":"python/tricks","link":"/categories/python/tricks/"},{"name":"tensorflow","slug":"深度学习/tensorflow","link":"/categories/深度学习/tensorflow/"},{"name":"dict","slug":"python/基础/dict","link":"/categories/python/基础/dict/"},{"name":"合集","slug":"python/bug/合集","link":"/categories/python/bug/合集/"},{"name":"远程","slug":"vscode/远程","link":"/categories/vscode/远程/"},{"name":"bug","slug":"深度学习/tensorflow/bug","link":"/categories/深度学习/tensorflow/bug/"}]}