{"pages":[{"title":"关于我","text":"欢迎来到我的个人博客! 研究深度学习方向, 正在做人脸识别项目 联系方式 EMail: hrduan@qq.com","link":"/about/index.html"}],"posts":[{"title":"My Test Post","text":"","link":"/2019/02/22/My-Test-Post/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/02/22/hello-world/"},{"title":"","text":"1. 计算部分1.1. / 、// 、 %除法(/)永远返回一个浮点数，如要使用 floor 除法 并且得到整数结果（丢掉任何小数部分），你可以使用 // 运算符；要计算余数你可以使用 %，使用 ** 运算符计算幂乘方123456789&gt;&gt;&gt; 17 / 3 # classic division returns a float5.666666666666667&gt;&gt;&gt;&gt;&gt;&gt; 17 // 3 # floor division discards the fractional part5&gt;&gt;&gt; 17 % 3 # the % operator returns the remainder of the division2&gt;&gt;&gt; 5 * 3 + 2 # result * divisor + remainder17 1234&gt;&gt;&gt; 5 ** 2 # 5 squared25&gt;&gt;&gt; 2 ** 7 # 2 to the power of 7128 1.2. 交互模式中，最近一个表达式的值赋给变量 _12345678&gt;&gt;&gt; tax = 12.5 / 100&gt;&gt;&gt; price = 100.50&gt;&gt;&gt; price * tax12.5625&gt;&gt;&gt; price + _ #这玩意有点秀113.0625&gt;&gt;&gt; round(_, 2)113.06 1.3. decimal——定点数和浮点数的数学运算简单mark一下啊，是精确计算用的Decimal类型是在浮点类型的基础上设计的,但是它在几个地方上要优于floating point:1)Decimal类型可以非常精确地在计算机中存储,而学过c++的都知道,浮点型在计算机中是无法精确存储的,比如1.1和2.2在计算机中存储后,运算(1.1+2.2)表达式的值结果会是3.3000000000000003;Decimal类型则不会出现这种情况。同样,由于无法精确存储,浮点型也就无法精确计算(相对于Decimal类型),可以再测试(0.1+0.1+0.1-0.3)两种类型的计算结果。2)Decimal类型会自动保留小数点后面不需要的0,以与输入的精度相匹配,比如下面小程序中的例子:浮点型的1.20+1.30结果是2.5;而Decimal类型结果是2.50,这样貌似比较人性化。3)Decimal类型可以根据需要自己设置小数点后精度。通过getcontext().prec = x (x为你想要的精度来设置,getcontext()函数下面再详细介绍)。4)Decimal类型有很强的管理功能,它能够根据需要设置,来控制输出的格式,得到或者忽略某类错误(如除0,可以设置忽略它,而得到一个Infinity的Decimal值)。 1.4. 行尾’\\‘,表示：下一行在逻辑上是本行的后续内容字符串文本能够分成多行。一种方法是使用三引号：&quot;&quot;&quot;...&quot;&quot;&quot;或者'''...'''。行尾换行符会被自动包含到字符串中，但是可以在行尾加上\\来避免这个行为。下面的示例： 可以使用反斜杠为行结尾的连续字符串，它表示下一行在逻辑上是本行的后续内容:123456789print(&quot;&quot;&quot;\\Usage: thingy [OPTIONS] -h Display this usage message -H hostname Hostname to connect to&quot;&quot;&quot;)# 将生成以下输出（注意，没有开始的第一行）:Usage: thingy [OPTIONS] -h Display this usage message -H hostname Hostname to connect to 2. 字符串，列表2.1. s[:i] + s[i:] 永远等于s:注意，包含起始的字符，不包含末尾的字符。 2.2. Python字符串不可以被更改 — 它们是 不可变的 。因此，赋值给字符串索引的位置会导致错误:123456&gt;&gt;&gt; word[0] = &apos;J&apos; ...TypeError: &apos;str&apos; object does not support item assignment&gt;&gt;&gt; word[2:] = &apos;py&apos; ...TypeError: &apos;str&apos; object does not support item assignment 2.3. 可以对切片赋值，此操作可以改变列表的尺寸，或清空它:切片操作返回列表一个新的（浅）拷贝副本list[3] = value,也可以看作是一个切片，所以会改变原列表123456789101112131415&gt;&gt;&gt; letters = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;]&gt;&gt;&gt; letters[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;]&gt;&gt;&gt; # replace some values&gt;&gt;&gt; letters[2:5] = [&apos;C&apos;, &apos;D&apos;, &apos;E&apos;]&gt;&gt;&gt; letters[&apos;a&apos;, &apos;b&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;f&apos;, &apos;g&apos;]&gt;&gt;&gt; # now remove them&gt;&gt;&gt; letters[2:5] = []&gt;&gt;&gt; letters[&apos;a&apos;, &apos;b&apos;, &apos;f&apos;, &apos;g&apos;]&gt;&gt;&gt; # clear the list by replacing all the elements with an empty list&gt;&gt;&gt; letters[:] = []&gt;&gt;&gt; letters[] 2.4. 创建list啧啧，有点秀12list = [None] * nn为已知长度 for 语句就是这样一个迭代器。list() 函数是另外一个（ 迭代器 ），它从可迭代（对象）中创建列表:12&gt;&gt;&gt; list(range(5))[0, 1, 2, 3, 4] 3. 控制语句3.1. 修改你迭代的序列（例如，复制选择项），你可以迭代它的复本, 如for w in word[:]:在迭代过程中修改迭代序列不安全（只有在使用链表这样的可变序列时才会有这样的情况）。使用切割标识就可以很方便的做到这一点:123456&gt;&gt;&gt; for w in words[:]: # Loop over a slice copy of the entire list.... if len(w) &gt; 6:... words.insert(0, w)...&gt;&gt;&gt; words[&apos;defenestrate&apos;, &apos;cat&apos;, &apos;window&apos;, &apos;defenestrate&apos;] 3.2. 循环可以有一个 else 子句与循环一起使用时，else 子句与 try 语句的 else 子句比与 if 语句的具有更多的共同点：try 语句的 else 子句在未出现异常时运行，循环的 else 子句在未出现 break 时运行。更多关于 try 语句和异常的内容，请参见 异常处理。 循环可以有一个 else 子句；它在循环迭代完整个列表（对于 for ）或执行条件为 false （对于 while）时执行，但循环被 break 中止的情况下不会执行。以下搜索素数的示例程序演示了这个子句:1234567891011121314151617&gt;&gt;&gt; for n in range(2, 10):... for x in range(2, n):... if n % x == 0:... print(n, &apos;equals&apos;, x, &apos;*&apos;, n//x)... break... else:... # loop fell through without finding a factor... print(n, &apos;is a prime number&apos;)...2 is a prime number3 is a prime number4 equals 2 * 25 is a prime number6 equals 2 * 37 is a prime number8 equals 2 * 49 equals 3 * 3 4. 函数4.1. 用一个逗号结尾就可以禁止输出换行:或者 print(something, end='')123456&gt;&gt;&gt; a, b = 0, 1&gt;&gt;&gt; while b &lt; 1000:... print(b, end=&apos;,&apos;)... a, b = b, a+b...1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987, 4.2. 函数的参数4.2.1. 默认参数要求用户确认的函数例子：1234567891011def ask_ok(prompt, retries=4, complaint=&apos;Yes or no, please!&apos;): while True: ok = input(prompt) if ok in (&apos;y&apos;, &apos;ye&apos;, &apos;yes&apos;): return True if ok in (&apos;n&apos;, &apos;no&apos;, &apos;nop&apos;, &apos;nope&apos;): return False retries = retries - 1 if retries &lt; 0: raise OSError(&apos;uncooperative user&apos;) print(complaint) 默认值在函数 定义 作用域被解析1234567i = 5def f(arg=i): # f函数在这一行定义，默认参数被解析 print(arg)i = 6f() 将会输出 5重要警告: 默认值只被赋值一次。当默认值是可变对象时会有所不同，比如列表、字典或者大多数类的实例。例如，下面的函数在后续调用过程中会累积（前面）传给它的参数:123456789101112def f(a, L=[]): L.append(a) return Lprint(f(1))print(f(2))print(f(3))# 输出[1][1, 2][1, 2, 3] 如果你不想让默认值在后续调用中累积，你可以像下面一样定义函数:12345def f(a, L=None): if L is None: L = [] L.append(a) return L 4.2.2. 可变参数列表本质：元组封装和序列拆封的一个结合让函数调用可变个数的参数。这些参数被包装进一个元组（参见 元组和序列 ）。在这些可变个数的参数之前，可以有零到多个普通的参数。这些可变参数是参数列表中的最后一个，因为它们将把所有的剩余输入参数传递给函数。任何出现在 *args 后的参数是关键字参数，这意味着，他们只能被用作关键字，而不是位置参数:1234567&gt;&gt;&gt; def concat(*args, sep=&quot;/&quot;):... return sep.join(args)...&gt;&gt;&gt; concat(&quot;earth&quot;, &quot;mars&quot;, &quot;venus&quot;)&apos;earth/mars/venus&apos;&gt;&gt;&gt; concat(&quot;earth&quot;, &quot;mars&quot;, &quot;venus&quot;, sep=&quot;.&quot;) # sep只能是关键字参数！&apos;earth.mars.venus&apos; 4.2.3. 关键字参数引入一个形如 **name 的参数时，它接收一个字典（参见 Mapping Types — dict ），该字典包含了所有未出现在形式参数列表中的关键字参数。这里可能还会组合使用一个形如 *name （下一小节详细介绍） 的形式参数，它接收一个元组（下一节中会详细介绍），包含了所有没有出现在形式参数列表中的参数值（*name 必须在 `name` 之前出现**）。123456789def cheeseshop(kind, *arguments, **keywords): print(&quot;-- Do you have any&quot;, kind, &quot;?&quot;) print(&quot;-- I&apos;m sorry, we&apos;re all out of&quot;, kind) for arg in arguments: print(arg) print(&quot;-&quot; * 40) keys = sorted(keywords.keys()) # 对关键字排序 for kw in keys: print(kw, &quot;:&quot;, keywords[kw]) 4.2.4. 参数列表的分拆—— * 拆开参数列表, ** 分拆字典为关键字参数当你要传递的参数已经是一个列表，但要调用的函数却接受分开一个个的参数值。这时候你要把已有的列表拆开来。例如内建函数 range() 需要要独立的 start，stop 参数。你可以在调用函数时加一个 * 操作符来自动把参数列表拆开:12345&gt;&gt;&gt; list(range(3, 6)) # normal call with separate arguments[3, 4, 5]&gt;&gt;&gt; args = [3, 6]&gt;&gt;&gt; list(range(*args)) # call with arguments unpacked from a list[3, 4, 5] 以同样的方式，可以使用 ** 操作符分拆关键字参数为字典:12345678&gt;&gt;&gt; def parrot(voltage, state=&apos;a stiff&apos;, action=&apos;voom&apos;):... print(&quot;-- This parrot wouldn&apos;t&quot;, action, end=&apos; &apos;)... print(&quot;if you put&quot;, voltage, &quot;volts through it.&quot;, end=&apos; &apos;)... print(&quot;E&apos;s&quot;, state, &quot;!&quot;)...&gt;&gt;&gt; d = {&quot;voltage&quot;: &quot;four million&quot;, &quot;state&quot;: &quot;bleedin&apos; demised&quot;, &quot;action&quot;: &quot;VOOM&quot;}&gt;&gt;&gt; parrot(**d)-- This parrot wouldn&apos;t VOOM if you put four million volts through it. E&apos;s bleedin&apos; demised ! 4.3. Lambda 形式使用 lambda 表达式返回一个函数，类似于嵌套函数定义，lambda 形式可以从外部作用域引用变量:12345678&gt;&gt;&gt; def make_incrementor(n):... return lambda x: x + n...&gt;&gt;&gt; f = make_incrementor(42)&gt;&gt;&gt; f(0)42&gt;&gt;&gt; f(1) 43 或将一个小函数作为参数传递:1234&gt;&gt;&gt; pairs = [(1, &apos;one&apos;), (2, &apos;two&apos;), (3, &apos;three&apos;), (4, &apos;four&apos;)]&gt;&gt;&gt; pairs.sort(key=lambda pair: pair[1]) &gt;&gt;&gt; pairs[(4, &apos;four&apos;), (1, &apos;one&apos;), (3, &apos;three&apos;), (2, &apos;two&apos;)] 4.4. 函数的文档字符串第一行应该是关于对象用途的简介。简短起见，不用明确的陈述对象名或类型，因为它们可以从别的途径了解到（除非这个名字碰巧就是描述这个函数操作的动词）。这一行应该以大写字母开头，以句号结尾。 如果文档字符串有多行，第二行应该空出来，与接下来的详细描述明确分隔。接下来的文档应该有一或多段描述对象的调用约定、边界效应等。 Python 的解释器不会从多行的文档字符串中去除缩进，所以必要的时候应当自己清除缩进。这符合通常的习惯。第一行之后的第一个非空行决定了整个文档的缩进格式。（我们不用第一行是因为它通常紧靠着起始的引号，缩进格式显示的不清楚。）留白“相当于”是字符串的起始缩进。每一行都不应该有缩进，如果有缩进的话，所有的留白都应该清除掉。留白的长度应当等于扩展制表符的宽度（通常是8个空格）。 以下是一个多行文档字符串的示例:1234567891011&gt;&gt;&gt; def my_function():... &quot;&quot;&quot;Do nothing, but document it....... No, really, it doesn&apos;t do anything.... &quot;&quot;&quot;... pass...&gt;&gt;&gt; print(my_function.__doc__)Do nothing, but document it. No, really, it doesn&apos;t do anything. 4.5. 编码风格对于 Python，PEP 8 引入了大多数项目遵循的风格指导。它给出了一个高度可读，视觉友好的编码风格。每个 Python 开发者都应该读一下，大多数要点都会对你有帮助： 使用 4 空格缩进，而非 TAB 在小缩进（可以嵌套更深）和大缩进（更易读）之间，4空格是一个很好的折中。TAB 引发了一些混乱，最好弃用 折行以确保其不会超过 79 个字符这有助于小显示器用户阅读，也可以让大显示器能并排显示几个代码文件 使用空行分隔函数和类，以及函数中的大块代码 可能的话，注释独占一行 使用文档字符串 把空格放到操作符两边，以及逗号后面，但是括号里侧不加空格：a = f(1, 2) + g(3, 4) 统一函数和类命名推荐类名用 驼峰命名， 函数和方法名用 小写_和_下划线。总是用 self 作为方法的第一个参数（关于类和方法的知识详见 初识类 ） 不要使用花哨的编码，如果你的代码的目的是要在国际化环境。Python 的默认情况下，UTF-8，甚至普通的 ASCII 总是工作的最好 同样，也不要使用非 ASCII 字符的标识符，除非是不同语种的会阅读或者维护代码。5. 数据结构5.1. 列表level up list.append(x)：把一个元素添加到列表的结尾 list.extend(L)：将一个给定列表中的所有元素都添加到另一个列表中 list.insert(i, x)：在指定位置插入一个元素 list.remove(x)： 删除列表中值为 x 的第一个元素。如果没有这样的元素，就会返回一个错误。 list.pop([i])： 如果没有指定索引，a.pop() 返回最后一个元素 list.clear()： 从列表中删除所有元素 list.index(x)：返回列表中第一个值为 x 的元素的索引。如果没有匹配的元素就会返回一个错误。 list.count(x)：返回 x 在列表中出现的次数。 list.sort()：对列表中的元素就地进行排序。 list.reverse()：就地倒排 list.copy()：返回列表的一个浅拷贝。等同于 a[:]。5.1.1. 把列表当作堆栈使用堆栈作为特定的数据结构，最先进入的元素最后一个被释放（后进先出）。用 append() 方法可以把一个元素添加到堆栈顶。用不指定索引的 pop()方法可以把一个元素从堆栈顶释放出来。例如:5.1.2. 把列表当作队列使用队列作为特定的数据结构，最先进入的元素最先释放（先进先出）。不过，列表这样用效率不高。要实现队列，使用 collections.deque，它为在首尾两端快速插入和删除而设计。例如:12345678910&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; queue = deque([&quot;Eric&quot;, &quot;John&quot;, &quot;Michael&quot;])&gt;&gt;&gt; queue.append(&quot;Terry&quot;) # Terry arrives&gt;&gt;&gt; queue.append(&quot;Graham&quot;) # Graham arrives&gt;&gt;&gt; queue.popleft() # The first to arrive now leaves&apos;Eric&apos;&gt;&gt;&gt; queue.popleft() # The second to arrive now leaves&apos;John&apos;&gt;&gt;&gt; queue # Remaining queue in order of arrivaldeque([&apos;Michael&apos;, &apos;Terry&apos;, &apos;Graham&apos;]) 5.2. del 语句从列表中按给定的索引而不是值来删除一个子项1234567891011&gt;&gt;&gt; a = [-1, 1, 66.25, 333, 333, 1234.5]&gt;&gt;&gt; del a[0]&gt;&gt;&gt; a[1, 66.25, 333, 333, 1234.5]&gt;&gt;&gt; del a[2:4]&gt;&gt;&gt; a[1, 66.25, 1234.5]&gt;&gt;&gt; del a[:]&gt;&gt;&gt; a[]&gt;&gt;&gt; del a # 也可以删除整个变量 5.3. 元组123456789&gt;&gt;&gt; t = 12345, 54321, &apos;hello!&apos;&gt;&gt;&gt; t[0]12345&gt;&gt;&gt; t(12345, 54321, &apos;hello!&apos;)&gt;&gt;&gt; # Tuples may be nested:... u = t, (1, 2, 3, 4, 5) # 封装成元组&gt;&gt;&gt; u((12345, 54321, &apos;hello!&apos;), (1, 2, 3, 4, 5)) 一对空的括号可以创建空元组创建一个单元素元组可以在值后面跟一个逗号（在括号中放入一个单值不够明确）1234&gt;&gt;&gt; empty = ()&gt;&gt;&gt; singleton = &apos;hello&apos;, # &lt;-- note trailing comma&gt;&gt;&gt; singleton(&apos;hello&apos;,) 元组拆分：x, y, z = t 5.4. 集合集合是一个无序不重复元素的集。基本功能包括关系测试和消除重复元素。集合对象还支持 union（联合），intersection（交），difference（差）和 sysmmetric difference（对称差集）等数学运算。注意：想要创建空集合，你必须使用 set() 而不是 {}。后者用于创建空字典。12345678910111213141516171819202122&gt;&gt;&gt; basket = {&apos;apple&apos;, &apos;orange&apos;, &apos;apple&apos;, &apos;pear&apos;, &apos;orange&apos;, &apos;banana&apos;}&gt;&gt;&gt; print(basket) # show that duplicates have been removed{&apos;orange&apos;, &apos;banana&apos;, &apos;pear&apos;, &apos;apple&apos;}&gt;&gt;&gt; &apos;orange&apos; in basket # fast membership testingTrue&gt;&gt;&gt; &apos;crabgrass&apos; in basketFalse&gt;&gt;&gt; # Demonstrate set operations on unique letters from two words...&gt;&gt;&gt; a = set(&apos;abracadabra&apos;)&gt;&gt;&gt; b = set(&apos;alacazam&apos;)&gt;&gt;&gt; a # unique letters in a{&apos;a&apos;, &apos;r&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;}&gt;&gt;&gt; a - b # letters in a but not in b{&apos;r&apos;, &apos;d&apos;, &apos;b&apos;}&gt;&gt;&gt; a | b # letters in either a or b{&apos;a&apos;, &apos;c&apos;, &apos;r&apos;, &apos;d&apos;, &apos;b&apos;, &apos;m&apos;, &apos;z&apos;, &apos;l&apos;}&gt;&gt;&gt; a &amp; b # letters in both a and b{&apos;a&apos;, &apos;c&apos;}&gt;&gt;&gt; a ^ b # letters in a or b but not both{&apos;r&apos;, &apos;d&apos;, &apos;b&apos;, &apos;m&apos;, &apos;z&apos;, &apos;l&apos;} 类似 列表推导式，这里有一种集合推导式语法:123&gt;&gt;&gt; a = {x for x in &apos;abracadabra&apos; if x not in &apos;abc&apos;}&gt;&gt;&gt; a{&apos;r&apos;, &apos;d&apos;} 5.5. 字典无序的键： 值对 （key:value 对）集合，键必须是互不相同的（在同一个字典之内）。一对大括号创建一个空的字典： {} 。初始化列表时，在大括号内放置一组逗号分隔的键：值对，这也是字典输出的方式。对一个字典执行 list(d.keys()) 将返回一个字典中所有关键字组成的无序列表（如果你想要排序，只需使用 sorted(d.keys()) ）。使用 in 关键字可以检查字典中是否存在某个关键字（指字典）。 直接从 key-value 对中创建字典: 12&gt;&gt;&gt; dict([(&apos;sape&apos;, 4139), (&apos;guido&apos;, 4127), (&apos;jack&apos;, 4098)]){&apos;sape&apos;: 4139, &apos;jack&apos;: 4098, &apos;guido&apos;: 4127} 字典推导式可以从任意的键值表达式中创建字典: 12&gt;&gt;&gt; {x: x**2 for x in (2, 4, 6)}{2: 4, 4: 16, 6: 36} 通过关键字参数指定 key-value 对: 12&gt;&gt;&gt; dict(sape=4139, guido=4127, jack=4098){&apos;sape&apos;: 4139, &apos;jack&apos;: 4098, &apos;guido&apos;: 4127} 5.6. 循环技巧 在字典中循环时，关键字和对应的值可以使用items() 方法同时解读出来: 123&gt;&gt;&gt; knights = {&apos;gallahad&apos;: &apos;the pure&apos;, &apos;robin&apos;: &apos;the brave&apos;}&gt;&gt;&gt; for k, v in knights.items():... print(k, v) 同时循环两个或更多的序列，可以使用 zip() 整体打包: 1234&gt;&gt;&gt; questions = [&apos;name&apos;, &apos;quest&apos;, &apos;favorite color&apos;]&gt;&gt;&gt; answers = [&apos;lancelot&apos;, &apos;the holy grail&apos;, &apos;blue&apos;]&gt;&gt;&gt; for q, a in zip(questions, answers):... print(&apos;What is your {0}? It is {1}.&apos;.format(q, a)) 逆向循环序列的话，先正向定位序列，然后调用 reversed() 函数: 12&gt;&gt;&gt; for i in reversed(range(1, 10, 2)):... print(i) 要按排序后的顺序循环序列的话，使用 sorted() 函数 123&gt;&gt;&gt; basket = [&apos;apple&apos;, &apos;orange&apos;, &apos;apple&apos;, &apos;pear&apos;, &apos;orange&apos;, &apos;banana&apos;]&gt;&gt;&gt; for f in sorted(set(basket)):... print(f) 要在循环内部修改正在遍历的序列（例如复制某些元素），建议您首先制作副本,使用切片表示法 1234&gt;&gt;&gt; words = [&apos;cat&apos;, &apos;window&apos;, &apos;defenestrate&apos;]&gt;&gt;&gt; for w in words[:]: # Loop over a slice copy of the entire list.... if len(w) &gt; 6:... words.insert(0, w) 5.7. 深入条件控制 比较操作符 in 和 not in 审核值是否在一个区间之内。操作符 is 和is not 比较两个对象是否相同 比较操作可以传递。例如a &lt; b == c 审核是否 a 小于b 并且b 等于c 比较操作可以通过逻辑操作符 and 和 or组合，比较的结果可以用 not来取反义。这些操作符的优先级又低于比较操作符，在它们之中，not 具有最高的优先级，or优先级最低，所以 A and not B or C 等于 (A and (notB)) or C5.8 比较序列和其它类型1234567(1, 2, 3) &lt; (1, 2, 4)[1, 2, 3] &lt; [1, 2, 4]&apos;ABC&apos; &lt; &apos;C&apos; &lt; &apos;Pascal&apos; &lt; &apos;Python&apos; # 字符串的字典序按照单字符的 ASCII 顺序(1, 2, 3, 4) &lt; (1, 2, 4)(1, 2) &lt; (1, 2, -1) # 如果一个序列是另一个序列的初始子序列，较短的一个序列就小于另一个(1, 2, 3) == (1.0, 2.0, 3.0) # 混合数值类型是通过它们的数值进行比较的，所以 0 是等于 0.0(1, 2, (&apos;aa&apos;, &apos;ab&apos;)) &lt; (1, 2, (&apos;abc&apos;, &apos;a&apos;), 4) 6. 模块6.1. 模块载入出于性能考虑，每个模块在每个解释器会话中只导入一遍。因此，如果你修改了你的模块，需要重启解释器；或者，如果你就是想交互式的测试这么一个模块，可以用 imp.reload() 重新加载，例如 import imp; imp.reload(modulename)。 6.2. 模块的搜索路径导入一个叫 spam 的模块时，解释器先在当前目录中搜索名为 spam.py 的文件。如果没有找到的话，接着会到 sys.path 变量中给出的目录列表中查找。 sys.path 变量的初始值来自如下： 输入脚本的目录（当前目录）。 环境变量 PYTHONPATH 表示的目录列表中搜索(这和 shell 变量 PATH 具有一样的语法，即一系列目录名的列表)。 Python 默认安装路径中搜索。 在支持符号连接的文件系统中，输入的脚本所在的目录是符号连接指向的目录。 换句话说也就是包含符号链接的目录不会被加到目录搜索路径中。 变量 sys.path 是解释器模块搜索路径的字符串列表。它由环境变量 PYTHONPATH 初始化，如果没有设定 PYTHONPATH ，就由内置的默认值初始化。你可以用标准的字符串操作修改它:12&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path.append(&apos;/ufs/guido/lib/python&apos;) 6.3. dir() 函数内置函数 dir() 用于按模块名搜索模块定义，它返回一个字符串类型的存储列表:123&gt;&gt;&gt; import fibo, sys&gt;&gt;&gt; dir(fibo)[&apos;__name__&apos;, &apos;fib&apos;, &apos;fib2&apos;] 无参数调用时，dir() 函数返回当前定义的命名:12345&gt;&gt;&gt; a = [1, 2, 3, 4, 5]&gt;&gt;&gt; import fibo&gt;&gt;&gt; fib = fibo.fib&gt;&gt;&gt; dir()[&apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__name__&apos;, &apos;a&apos;, &apos;fib&apos;, &apos;fibo&apos;, &apos;sys&apos;] 该列表列出了所有类型的名称：变量，模块，函数，等等。dir() 不会列出内置函数和变量名。如果你想列出这些内容，它们在标准模块 builtins 中定义:12&gt;&gt;&gt; import builtins&gt;&gt;&gt; dir(builtins) 6.4. 包一个声音处理的模块集，目录结构如下：1234567891011121314151617181920212223sound/ Top-level package __init__.py Initialize the sound package formats/ Subpackage for file format conversions __init__.py wavread.py wavwrite.py aiffread.py aiffwrite.py auread.py auwrite.py ... effects/ Subpackage for sound effects __init__.py echo.py surround.py reverse.py ... filters/ Subpackage for filters __init__.py equalizer.py vocoder.py karaoke.py ... 当导入这个包时，Python 通过 sys.path 搜索路径查找包含这个包的子目录。为了让 Python 将目录当做内容包，目录中必须包含 __init__.py 文件。最简单的情况下，只需要一个空的 __init__.py 文件即可。当然它也可以执行包的初始化代码，或者定义稍后介绍的 __all__ 变量。 6.4.1. 导入包的几种方式：1234# 加载 echo 子模块echo.echofilter(input, output, delay=0.7, atten=4)# 直接导入函数或变量from sound.effects.echo import echofilter 6.4.2. 从 * 导入包提供一个明确的包索引。import 语句按如下条件进行转换：执行 from package import * 时，如果包中的 __init__.py 代码定义了一个名为 __all__ 的列表，就会按照列表中给出的模块名进行导入。新版本的包发布时作者可以任意更新这个列表。如果包作者不想 import 的时候导入他们的包中所有模块，那么也可能会决定不支持它（ import ）。例如， sound/effects/__init__.py 这个文件可能包括如下代码:1__all__ = [&quot;echo&quot;, &quot;surround&quot;, &quot;reverse&quot;] 这意味着from sound.effects import 语句会从 sound 包中导入以上三个已命名的子模块。 6.4.3. 包内引用可以用这样的形式from module import name 来写显式的相对位置导入。那些显式相对导入用点号标明关联导入当前和上级包。以 surround 模块为例，你可以这样用:123from . import echofrom .. import formatsfrom ..filters import equalizer 需要注意的是显式或隐式相对位置导入都基于当前模块的命名。因为主模块的名字总是&quot;__main__&quot;，Python 应用程序的主模块应该总是用绝对导入。 7. 输入和输出7.1. 格式化输出这里有两种大相径庭地输出值方法：表达式语句 和 print() 函数（第三种访求是使用文件对象的 write() 方法，标准文件输出可以参考 sys.stdout，详细内容参见库参考手册）。 str.format() 方法提供了丰富的格式控制。如何将值转化为字符串？Python 有办法将任意值转为字符串：将它传入 repr() 或 str() 函数。函数 str() 用于将值转化为适于人阅读的形式，而 repr() 转化为供解释器读取的形式（如果没有等价的语法，则会发生 SyntaxError 异常）某对象没有适于人阅读的解释形式的话，str() 会返回与 repr()等同的值。 7.2. str的一些方法 str.rjust() 方法，它把字符串输出到一列，并通过向左侧填充空格来使其右对齐。类似的方法还有 str.ljust() 和 str.center()。这些函数只是输出新的字符串，并不改变什么。如果输出的字符串太长，它们也不会截断它，而是原样输出。如果你确实需要截断它，可以使用切割操作，例如：x.ljust(n)[:n]。 str.zfill() 它用于向数值的字符串表达左侧填充 0。该函数可以正确理解正负号: 123456&gt;&gt;&gt; &apos;12&apos;.zfill(5)&apos;00012&apos;&gt;&gt;&gt; &apos;-3.14&apos;.zfill(7)&apos;-003.14&apos;&gt;&gt;&gt; &apos;3.14159265359&apos;.zfill(5)&apos;3.14159265359&apos; str.format() 的基本用法如下: 12&gt;&gt;&gt; print(&apos;We are the {} who say &quot;{}!&quot;&apos;.format(&apos;knights&apos;, &apos;Ni&apos;))We are the knights who say &quot;Ni!&quot; 大括号和其中的字符会被替换成传入 str.format() 的参数。大括号中的数值指明使用传入 str.format()方法的对象中的哪一个:1234&gt;&gt;&gt; print(&apos;{0} and {1}&apos;.format(&apos;spam&apos;, &apos;eggs&apos;))spam and eggs&gt;&gt;&gt; print(&apos;{1} and {0}&apos;.format(&apos;spam&apos;, &apos;eggs&apos;))eggs and spam 如果在 str.format() 调用时使用关键字参数，可以通过参数名来引用值:123&gt;&gt;&gt; print(&apos;This {food} is {adjective}.&apos;.format(... food=&apos;spam&apos;, adjective=&apos;absolutely horrible&apos;))This spam is absolutely horrible. 位置参数和关键字参数可以随意组合:123&gt;&gt;&gt; print(&apos;The story of {0}, {1}, and {other}.&apos;.format(&apos;Bill&apos;, &apos;Manfred&apos;, other=&apos;Georg&apos;))The story of Bill, Manfred, and Georg. '!a' (应用 ascii())，'!s' （应用 str() ）和 '!r' （应用 repr() ）可以在格式化之前转换值:12345&gt;&gt;&gt; import math&gt;&gt;&gt; print(&apos;The value of PI is approximately {}.&apos;.format(math.pi))The value of PI is approximately 3.14159265359.&gt;&gt;&gt; print(&apos;The value of PI is approximately {!r}.&apos;.format(math.pi))The value of PI is approximately 3.141592653589793. 字段名后允许可选的':' 和格式指令。下例将 Pi 转为三位精度。123&gt;&gt;&gt; import math&gt;&gt;&gt; print(&apos;The value of PI is approximately {0:.3f}.&apos;.format(math.pi))The value of PI is approximately 3.142. 在字段后的 ‘:’ 后面加一个整数会限定该字段的最小宽度，这在美化表格时很有用:1234567&gt;&gt;&gt; table = {&apos;Sjoerd&apos;: 4127, &apos;Jack&apos;: 4098, &apos;Dcab&apos;: 7678}&gt;&gt;&gt; for name, phone in table.items():... print(&apos;{0:10} ==&gt; {1:10d}&apos;.format(name, phone))...Jack ==&gt; 4098Dcab ==&gt; 7678Sjoerd ==&gt; 4127 可以用命名来引用被格式化的变量而不是位置。传入一个字典，用中括号( '[]')访问它的键:1234&gt;&gt;&gt; table = {&apos;Sjoerd&apos;: 4127, &apos;Jack&apos;: 4098, &apos;Dcab&apos;: 8637678}&gt;&gt;&gt; print(&apos;Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; &apos; &apos;Dcab: {0[Dcab]:d}&apos;.format(table))Jack: 4098; Sjoerd: 4127; Dcab: 8637678 也可以用 ‘**’ 标志将这个字典以关键字参数的方式传入:123&gt;&gt;&gt; table = {&apos;Sjoerd&apos;: 4127, &apos;Jack&apos;: 4098, &apos;Dcab&apos;: 8637678}&gt;&gt;&gt; print(&apos;Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: {Dcab:d}&apos;.format(**table))Jack: 4098; Sjoerd: 4127; Dcab: 8637678 这种方式与新的内置函数 vars() 组合使用非常有效。该函数返回包含所有局部变量的字典。 要进一步了解字符串格式化方法 str.format()，参见 格式字符串语法。 7.2. 文件读写函数 open() 返回 文件对象，通常的用法需要两个参数：open(filename, mode)。1&gt;&gt;&gt; f = open(&apos;workfile&apos;, &apos;w&apos;) 第一个参数是一个含有文件名的字符串。第二个参数也是一个字符串，含有描述如何使用该文件的几个字符。mode 为 ‘r’ 时表示只是读取文件；’w’ 表示只是写入文件（已经存在的同名文件将被删掉）；’a’ 表示打开文件进行追加，写入到文件中的任何数据将自动添加到末尾。 ‘r+’ 表示打开文件进行读取和写入。mode 参数是可选的，默认为 ‘r’。 通常，文件以 文本 打开，这意味着，你从文件读出和向文件写入的字符串会被特定的编码方式（默认是UTF-8）编码。模式后面的 ‘b’ 以 二进制模式 打开文件：数据会以字节对象的形式读出和写入。这种模式应该用于所有不包含文本的文件。 在文本模式下，读取时默认会将平台有关的行结束符（Unix上是 \\n , Windows上是 \\r\\n）转换为 \\n。在文本模式下写入时，默认会将出现的 \\n 转换成平台有关的行结束符。这种暗地里的修改对 ASCII 文本文件没有问题，但会损坏 JPEG 或 EXE 这样的二进制文件中的数据。使用二进制模式读写此类文件时要特别小心。 7.2.1. 文件对象方法要读取文件内容，需要调用f.read(size)，该方法读取若干数量的数据并以字符串形式返回其内容，size 是可选的数值，指定字符串长度。如果没有指定 size 或者指定为负数，就会读取并返回整个文件。当文件大小为当前机器内存两倍时，就会产生问题。反之，会尽可能按比较大的 * 读取和返回数据。如果到了文件末尾，f.read() 会返回一个空字符串（''）:1234&gt;&gt;&gt; f.read()&apos;This is the entire file.\\n&apos;&gt;&gt;&gt; f.read()&apos;&apos; f.readline()从文件中读取单独一行，字符串结尾会自动加上一个换行符（\\n ），只有当文件最后一行没有以换行符结尾时，这一操作才会被忽略。 如果f.readline() 返回一个空字符串，那就表示到达了文件末尾 如果是一个空行，就会描述为 '\\n'，一个只包含换行符的字符串:123456&gt;&gt;&gt; f.readline()&apos;This is the first line of the file.\\n&apos;&gt;&gt;&gt; f.readline()&apos;Second line of the file\\n&apos;&gt;&gt;&gt; f.readline()&apos;&apos; 把文件中的所有行读到一个列表中，可以使用 list(f) 或者f.readlines()。 f.write(string) 方法将 string 的内容写入文件，并返回写入字符的长度:12&gt;&gt;&gt; f.write(&apos;This is a test\\n&apos;)15 想要写入其他非字符串内容，首先要将它转换为字符串。 当你使用完一个文件时，调用 f.close() 方法就可以关闭它并释放其占用的所有系统资源。 在调用 f.close() 方法后，试图再次使用文件对象将会自动失败。用关键字 with 处理文件对象是个好习惯。它的先进之处在于文件用完后会自动关闭，就算发生异常也没关系。它是 try-finally 块的简写:1234&gt;&gt;&gt; with open(&apos;workfile&apos;, &apos;r&apos;) as f:... read_data = f.read()&gt;&gt;&gt; f.closedTrue 7.2.2. 使用 json 存储结构化数据Python 允许你使用常用的数据交换格式 JSON（JavaScript Object Notation）。标准模块 json 可以接受 Python 数据结构，并将它们转换为字符串表示形式；此过程称为 序列化。从字符串表示形式重新构建数据结构称为 反序列化。序列化和反序列化的过程中，表示该对象的字符串可以存储在文件或数据中，也可以通过网络连接传送给远程的机器。如果你有一个对象 x，你可以用简单的一行代码查看其 JSON 字符串表示形式:12&gt;&gt;&gt; json.dumps([1, &apos;simple&apos;, &apos;list&apos;])&apos;[1, &quot;simple&quot;, &quot;list&quot;]&apos; dumps() 函数的另外一个变体 dump()，直接将对象序列化到一个文件。所以如果 f 是为写入而打开的一个 文件对象，我们可以这样做:1json.dump(x, f) 为了重新解码对象，如果 f 是为读取而打开的 文件对象:1x = json.load(f) 这种简单的序列化技术可以处理列表和字典，但序列化任意类实例为 JSON 需要一点额外的努力。 json 模块的手册对此有详细的解释。 7.2.3. pickle - pickle 模块与 JSON 不同，pickle 是一个协议，它允许任意复杂的 Python 对象的序列化。因此，它只能用于 Python 而不能用来与其他语言编写的应用程序进行通信。默认情况下它也是不安全的：如果数据由熟练的攻击者精心设计， 反序列化来自一个不受信任源的 pickle 数据可以执行任意代码。 8. 错误和异常Python 中（至少）有两种错误：语法错误和异常（ syntax errors 和 exceptions ）。 8.1. 语法错误语法错误，也被称作解析错误。这是最常见的错误，往往是由于缺少冒号或者括号等引起。12345&gt;&gt;&gt; while True print(&apos;Hello world&apos;) File &quot;&lt;stdin&gt;&quot;, line 1, in ? while True print(&apos;Hello world&apos;) ^SyntaxError: invalid syntax 语法分析器指出错误行，并且在检测到错误的位置前面显示一个小“箭头”。 错误是由箭头 前面 的标记引起的（或者至少是这么检测的）： 这个例子中，函数 print() 被发现存在错误，因为它前面少了一个冒号（ ':' ）。 错误会输出文件名和行号。 8.2. 异常即使一条语句或表达式在语法上是正确的，当试图执行它时也可能会引发错误。运行期检测到的错误称为 异常，并且程序不会无条件的崩溃：123456789101112&gt;&gt;&gt; 10 * (1/0)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?ZeroDivisionError: int division or modulo by zero&gt;&gt;&gt; 4 + spam*3Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?NameError: name &apos;spam&apos; is not defined&gt;&gt;&gt; &apos;2&apos; + 2Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?TypeError: Can&apos;t convert &apos;int&apos; object to str implicitly 错误信息的最后一行指出发生了什么错误。异常也有不同的类型，异常类型做为错误信息的一部分显示出来：示例中的异常分别为 零除错误（ ZeroDivisionError ） ，命名错误（ NameError） 和 类型错误（ TypeError ）。打印错误信息时，异常的类型作为异常的内置名显示。对于所有的内置异常都是如此，不过用户自定义异常就不一定了（尽管这是一个很有用的约定）。标准异常名是内置的标识（没有保留关键字）。 这一行后一部分是关于该异常类型的详细说明，这意味着它的内容依赖于异常类型。 错误信息的前半部分以堆栈的形式列出异常发生的位置。通常在堆栈中列出了源代码行，然而，来自标准输入的源码不会显示出来。 内置的异常 列出了内置异常和它们的含义。 8.3. 异常处理通过编程处理选择的异常是可行的。看一下下面的例子：它会一直要求用户输入，直到输入一个合法的整数为止，但允许用户中断这个程序（使用 Control-C 或系统支持的任何方法）。注意：用户产生的中断会引发一个 KeyboardInterrupt 异常。1234567&gt;&gt;&gt; while True:... try:... x = int(input(&quot;Please enter a number: &quot;))... break... except ValueError:... print(&quot;Oops! That was no valid number. Try again...&quot;)... 8.3.1 try - except - else 语句try 语句按如下方式工作。 首先，执行 try 子句 （在 try 和 except 关键字之间的部分）。 如果没有异常发生， except 子句 在 try 语句执行完毕后就被忽略了。 如果在 try 子句执行过程中发生了异常，那么该子句其余的部分就会被忽略。如果异常匹配于 except 关键字后面指定的异常类型，就执行对应的except子句。然后继续执行 try 语句之后的代码。 如果发生了一个异常，在 except 子句中没有与之匹配的分支，它就会传递到上一级 try 语句中。如果最终仍找不到对应的处理语句，它就成为一个 未处理异常，终止程序运行，显示提示信息。 一个 try 语句可能包含多个 except 子句，分别指定处理不同的异常。至多只会有一个分支被执行。异常处理程序只会处理对应的 try 子句中发生的异常，在同一个 try 语句中，其他子句中发生的异常则不作处理。一个 except 子句可以在括号中列出多个异常的名字，例如:12... except (RuntimeError, TypeError, NameError):... pass 最后一个 except 子句可以省略异常名称，以作为通配符使用。你需要慎用此法，因为它会轻易隐藏一个实际的程序错误！可以使用这种方法打印一条错误信息，然后重新抛出异常（允许调用者处理这个异常):12345678910111213import systry: f = open(&apos;myfile.txt&apos;) s = f.readline() i = int(s.strip())except OSError as err: print(&quot;OS error: {0}&quot;.format(err))except ValueError: print(&quot;Could not convert data to an integer.&quot;)except: print(&quot;Unexpected error:&quot;, sys.exc_info()[0]) raise try … except 语句可以带有一个 else子句，该子句只能出现在所有 except 子句之后。当 try 语句没有抛出异常时，需要执行一些代码，可以使用这个子句。例如:12345678for arg in sys.argv[1:]: try: f = open(arg, &apos;r&apos;) except IOError: print(&apos;cannot open&apos;, arg) else: print(arg, &apos;has&apos;, len(f.readlines()), &apos;lines&apos;) f.close() 使用 else 子句比在 try 子句中附加代码要好，因为这样可以避免 try … except 意外的截获本来不属于它们保护的那些代码抛出的异常。 8.3.2 异常的参数发生异常时，可能会有一个附属值，作为异常的 参数 存在。这个参数是否存在、是什么类型，依赖于异常的类型。 在异常名（列表）之后，也可以为 except 子句指定一个变量。这个变量绑定于一个异常实例，它存储在 instance.args 的参数中。为了方便起见，异常实例定义了 str () ，这样就可以直接访问过打印参数而不必引用 .args。这种做法不受鼓励。相反，更好的做法是给异常传递一个参数（如果要传递多个参数，可以传递一个元组），把它绑定到 message 属性。一旦异常发生，它会在抛出前绑定所有指定的属性。12345678910111213141516&gt;&gt;&gt; try:... raise Exception(&apos;spam&apos;, &apos;eggs&apos;)... except Exception as inst:... print(type(inst)) # the exception instance... print(inst.args) # arguments stored in .args... print(inst) # __str__ allows args to be printed directly,... # but may be overridden in exception subclasses... x, y = inst.args # unpack args... print(&apos;x =&apos;, x)... print(&apos;y =&apos;, y)...&lt;class &apos;Exception&apos;&gt;(&apos;spam&apos;, &apos;eggs&apos;)(&apos;spam&apos;, &apos;eggs&apos;)x = spamy = eggs 对于那些未处理的异常，如果一个它们带有参数，那么就会被作为异常信息的最后部分（“详情”）打印出来。 异常处理器不仅仅处理那些在 try 子句中立刻发生的异常，也会处理那些 try 子句中调用的函数内部发生的异常。 8.4. 抛出异常raise 语句允许程序员强制抛出一个指定的异常。例如:1234&gt;&gt;&gt; raise NameError(&apos;HiThere&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?NameError: HiThere 要抛出的异常由 raise 的唯一参数标识。它必需是一个异常实例或异常类（继承自 Exception 的类）。 如果你需要明确一个异常是否抛出，但不想处理它，raise 语句可以让你很简单的重新抛出该异常:12345678910&gt;&gt;&gt; try:... raise NameError(&apos;HiThere&apos;)... except NameError:... print(&apos;An exception flew by!&apos;)... raise...An exception flew by!Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 2, in ?NameError: HiThere 8.5. 用户自定义异常在程序中可以通过创建新的异常类型来命名自己的异常。异常类通常应该直接或间接的从 Exception 类派生，例如:12345678910111213141516&gt;&gt;&gt; class MyError(Exception):... def __init__(self, value):... self.value = value... def __str__(self):... return repr(self.value)...&gt;&gt;&gt; try:... raise MyError(2*2)... except MyError as e:... print(&apos;My exception occurred, value:&apos;, e.value)...My exception occurred, value: 4&gt;&gt;&gt; raise MyError(&apos;oops!&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?__main__.MyError: &apos;oops!&apos; 在这个例子中，Exception 默认的 init() 被覆盖。新的方式简单的创建 value 属性。这就替换了原来创建 args 属性的方式。 异常类中可以定义任何其它类中可以定义的东西，但是通常为了保持简单，只在其中加入几个属性信息，以供异常处理句柄提取。如果一个新创建的模块中需要抛出几种不同的错误时，一个通常的作法是为该模块定义一个异常基类，然后针对不同的错误类型派生出对应的异常子类:123456789101112131415161718192021222324252627282930class Error(Exception): &quot;&quot;&quot;Base class for exceptions in this module.&quot;&quot;&quot; passclass InputError(Error): &quot;&quot;&quot;Exception raised for errors in the input. Attributes: expression -- input expression in which the error occurred message -- explanation of the error &quot;&quot;&quot; def __init__(self, expression, message): self.expression = expression self.message = messageclass TransitionError(Error): &quot;&quot;&quot;Raised when an operation attempts a state transition that&apos;s not allowed. Attributes: previous -- state at beginning of transition next -- attempted new state message -- explanation of why the specific transition is not allowed &quot;&quot;&quot; def __init__(self, previous, next, message): self.previous = previous self.next = next self.message = message 8.6. 定义清理行为try 语句还有另一个可选的子句，目的在于定义在任何情况下都一定要执行的功能。例如:12345678910111213141516171819202122&gt;&gt;&gt; def divide(x, y):... try:... result = x / y... except ZeroDivisionError:... print(&quot;division by zero!&quot;)... else:... print(&quot;result is&quot;, result)... finally:... print(&quot;executing finally clause&quot;)...&gt;&gt;&gt; divide(2, 1)result is 2executing finally clause&gt;&gt;&gt; divide(2, 0)division by zero!executing finally clause&gt;&gt;&gt; divide(&quot;2&quot;, &quot;1&quot;)executing finally clauseTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ? File &quot;&lt;stdin&gt;&quot;, line 3, in divideTypeError: unsupported operand type(s) for /: &apos;str&apos; and &apos;str&apos; 不管有没有发生异常，finally子句 在程序离开 try 后都一定会被执行。当 try 语句中发生了未被 except 捕获的异常（或者它发生在 except 或 else 子句中），在 finally 子句执行完后它会被重新抛出。 try 语句经由 break ，continue 或 return 语句退 出也一样会执行 finally 子句。 finally 子句在任何情况下都会执行。TypeError 在两个字符串相除的时候抛出，未被 except 子句捕获，因此在 finally 子句执行完毕后重新抛出。 在真实场景的应用程序中，finally 子句用于释放外部资源（文件 或网络连接之类的），无论它们的使用过程中是否出错。 9. 类 Python中的作用域及global用法python中global 和 nonlocal 的作用域9.7. 补充有时类似于 Pascal 中“记录（record）”或 C 中“结构（struct）”的数据类型很有用，它将一组已命名的数据项绑定在一起。一个空的类定义可以很好的实现它: 10.10. 性能度量有些用户对了解解决同一问题的不同方法之间的性能差异很感兴趣。Python 提供了一个度量工具，为这些问题提供了直接答案。 例如，使用元组封装和拆封来交换元素看起来要比使用传统的方法要诱人的多。timeit 证明了后者更快一些: 12345&gt;&gt;&gt; from timeit import Timer&gt;&gt;&gt; Timer(&apos;t=a; a=b; b=t&apos;, &apos;a=1; b=2&apos;).timeit()0.57535828626024577&gt;&gt;&gt; Timer(&apos;a,b = b,a&apos;, &apos;a=1; b=2&apos;).timeit()0.54962537085770791&lt;/pre&gt; 相对于 timeit 的细粒度，profile 和 pstats 模块提供了针对更大代码块的时间度量工具。 pip freeze 将会生成一个类似需要安装的包的列表，但是输出采用了 pip install 期望的格式。常见的做法就是把它们放在一个 requirements.txt 文件: requirements.txt 能够被提交到版本控制中并且作为一个应用程序的一部分。用户们可以使用 install -r 安装所有必须的包: what’s morehttp://www.pythondoc.com/pythontutorial3/classes.html","link":"/2019/02/23/python-速成集中营-—-预览版/"},{"title":"通过在vscode配置sftp, 远程修改服务器文件","text":"安装sftp扩展在vscode扩展中搜索sftp，下载量超过一百万的那个就是了，作者是liximomo。 按F1键搜索SFTP:Config,接下来配置sftp.json, 注意不要注释1234567891011121314151617181920212223242526{ &quot;host&quot;: &quot;server-ip&quot;, &quot;port&quot;: server-port, &quot;username&quot;: &quot;***&quot;, &quot;password&quot;: &quot;***&quot;, &quot;protocol&quot;: &quot;sftp&quot;, &quot;agent&quot;: null, &quot;privateKeyPath&quot;: null, &quot;passphrase&quot;: null, &quot;passive&quot;: false, &quot;interactiveAuth&quot;: true, &quot;remotePath&quot;: &quot;yourfolderpath&quot;, &quot;uploadOnSave&quot;: true, &quot;syncMode&quot;: &quot;update&quot;, &quot;ignore&quot;: [ &quot;**/.vscode/**&quot;, &quot;**/.git/**&quot;, &quot;**/.DS_Store&quot; ], &quot;watcher&quot;: { &quot;files&quot;: &quot;glob&quot;, &quot;autoUpload&quot;: true, &quot;autoDelete&quot;: true }} 在本地编辑远程文件并测试按F1键搜索view:Show SFTP，在vscode的右侧会出现SFTP的图标，在这里可以查看到远程文件打开一个远程文件初始内容是现在我们修改一下需要注意的是，修改完成后你保存的只是本地副本，还需要经过上传，才能达到真正修改的目的，右键选择upload即可，为了方便起见，这里修改一下快捷键，连续按下ctrl+k和ctrl+s，再ctrl+f搜索upload，将对应项快捷键设为ctrl+alt+s上传之后，源文件就已经和本地编辑器相同了","link":"/2019/01/20/vscode-+-sftp/"}],"tags":[{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"sftp","slug":"sftp","link":"/tags/sftp/"},{"name":"远程连接","slug":"远程连接","link":"/tags/远程连接/"},{"name":"服务器","slug":"服务器","link":"/tags/服务器/"}],"categories":[{"name":"vscode","slug":"vscode","link":"/categories/vscode/"},{"name":"远程","slug":"vscode/远程","link":"/categories/vscode/远程/"}]}